\chapter{拡張後の\tool の実装}\label{cha:Implementation}

本章では、拡張後の\tool の実装について説明する。
なお、本研究の拡張はWindows OSにのみ対応しており、それ以外のOSには対応していない。
拡張後の\tool のシステム構成を、図\ref{fig:system-architecture}に示す。

本研究で拡張後の\tool は、既存の\tool 同様にMVVMアーキテクチャ(\ref{sec:MVVM}節を参照)を採用している。MVVMアーキテクチャ実装のために、本研究では
CommunityToolkit.Mvvmを使用している。
拡張後の\tool は、以下の6つの主要な処理部で構成する。
\begin{figure}[tp]
  \centering
  \includegraphics[width=0.8\linewidth]{./images/system-architecture.png}
  \caption{拡張後の\tool のシステム構成}
  \label{fig:system-architecture}
\end{figure}

\begin{itemize}
      \item View 層
      \begin{itemize}
            \item 描画部
      \end{itemize}
      \item ViewModel 層
      \begin{itemize}
            \item ユーザ操作対応部
      \end{itemize}
      \item Model 層
      \begin{itemize}
            \item プロジェクト管理部
            \item 解析部
            \item GUI要素生成部
            \item 変換部
      \end{itemize}
\end{itemize}

MVVM に基づき、各処理部は責務を明確にし、連携して動作する。
View 層は、GUIの表示、および、ユーザ入力の受付を担う。具体的には、描画部はツールの外観の整形、ページの切り替え、ユーザ入力の受付、CTMの可視化を行う。
ViewModel 層は、View 層と Model 層間のデータバインディングを担う。
具体的には、ユーザ操作対応部は、ユーザ操作に対応するイベントハンドラを持ち、
Model 層のプロジェクト管理部、および、View 層の描画部へ処理の実行を指示する。
Model 層は、プロジェクト管理部、解析部、GUI要素生成部、および、変換部から構成する。
具体的には、プロジェクト管理部は、プロジェクトフォルダの読み込み、
Markdown仕様の管理、各処理部間のデータ受け渡し、
および、プロジェクトフォルダへのファイルの出力を担う。
解析部は、Markdown仕様を解析し、CTM要素(\ref{sec:CTM}節を参照)の抽出を担う。
GUI要素生成部は、解析部で抽出したCTM要素に、CTM領域上での表示、および、操作に必要なGUI属性である座標やサイズの付与を担う。
変換部は、GUI操作による編集結果をMarkdown仕様、および、\VDM 仕様への変換を担う。
この構成により、Model 層は View 層を直接参照せず、
ViewModel 層を介してのみ情報を受け渡す。

以降、各処理部の実装について、それぞれ説明する。

\section{描画部}\label{sec:DrawingComponent}
描画部は、ユーザの入力の受付、および、ユーザ操作対応部(\ref{sec:UserOperationMonitoring}節を参照)から受け取るデータをもとに、ツールの外観の成形、
表示ページの切り替え、操作ボタン領域に設置する操作ボタンの表示、\VDM 仕様表示領域の\VDM 仕様の表示、フォルダツリー表示領域のフォルダツリーの表示、および、CTM領域のCTMの表示を行う処理部である。

本処理部は、.NET MAUIの標準ライブラリであるMicrosoft.Maui.Controls(\ref{sec:NET_MAUI}節を参照)を用いて実装する。

描画部は、以下に示す9つの処理から成る。
\begin{itemize}
      \item ページ切替処理(\ref{sec:PageSwitch}節を参照)
      \item 操作ボタン生成および表示切替処理(\ref{sec:DrawingComponent_OperationButtons}節を参照)
      \item フォルダツリー描画処理(\ref{sec:FolderTree}節を参照)
      \item \VDM 描画処理(\ref{sec:DrawVDM}節を参照)
      \item メニューバー描画処理(\ref{sec:MenuBarDrawing}節を参照)
      \item CTM領域描画処理(\ref{sec:CTMArea}節を参照)
      \item CTM生成処理(\ref{sec:CreateCTM}節を参照)
      \item コンテキストメニュー描画処理(\ref{sec:Context}節を参照)
      \item ダイアログ描画処理(\ref{sec:Dialog}節を参照)
\end{itemize}

以降で、各処理を説明する。

\subsection{ページ切替処理}
\label{sec:PageSwitch}

ページ切替処理は、ユーザによる特定のボタン操作をもとに、「スタートページ」(\ref{sec:start-page}節を参照)、「Markdown仕様記述ページ」(\ref{sec:MarkdownPage}節を参照)
、および、「GUI操作による\VDM 仕様編集ページ」(\ref{sec:NoCodePage}節を参照)
を切り替える処理である。

「スタートページ」は、本研究の拡張で新たに追加する、ツール起動時に最初に表示する画面であり、
「Markdown仕様記述ページ」、
および、「GUI操作による\VDM 仕様編集ページ」の
2つのページへ遷移するための入口として機能する。
「スタートページ」には、
「Markdown仕様記述ページ」、
および、「GUI操作による\VDM 仕様編集ページ」
へ遷移する2つのボタンである「Markdown」ボタンと「NoCode」ボタンを配置する。

「Markdown仕様記述ページ」、および、「GUI操作による\VDM 仕様編集ページ」には、
本処理を実行するための「スタートページへ戻る」ボタンを設置する。

この3つのボタンには、
画面遷移コマンドを割り当てている。
これらのコマンドは、
ボタン押下時に.NET MAUIの標準ライブラリであるMicrosoft.Maui.Controls(\ref{sec:NET_MAUI}節を参照)にある
画面遷移全体を管理するためのクラスであるShellと、ShellベースのナビゲーションAPIであるGoToAsyncを呼び出すことで、
対応するページへの画面遷移を実現する。
このとき、各ページは、
それぞれShellのルーティング機構を用いて識別し、
アプリケーション全体で一貫した遷移管理を行う。

起動直後を例に、本処理の流れを以下に示す。
\begin{enumerate}
  \item ツール起動時、Shell により定義した、
  「スタートページ」を初期画面として生成し表示する。

  \item 「スタートページ」において、ユーザが「Markdown」ボタン、または、「NoCode」ボタンを押下した際に、
  「Markdown仕様記述ページ」、または、「GUI操作による\VDM 仕様編集ページ」へ遷移する。
\begin{itemize}
  \item ユーザがスタートページ上の「Markdown」ボタンを押下した場合、
  ボタンのクリックイベントをトリガとして、Shellのナビゲーション機構を用いて、
  「Markdown仕様記述ページ」へ遷移する。

  \item ユーザがスタートページ上の「NoCode」ボタンを押下した場合、
  ボタンのクリックイベントをトリガとして、
  Shellのナビゲーション機構を用いて、
  「GUI操作による\VDM 仕様編集ページ」へ遷移する。

  \end{itemize}
  \item 「Markdown仕様記述ページ」、または、「GUI操作による\VDM 仕様編集ページ」において、
  ユーザが「スタートページへ戻る」ボタンを押下した場合、
  押下イベントをトリガとしてShellのナビゲーション機構を用いて、「スタートページ」へ遷移する。
\end{enumerate}

\subsection{操作ボタン生成および表示切替処理}
\label{sec:DrawingComponent_OperationButtons}

本処理は、「GUI操作による\VDM 仕様編集ページ」の操作ボタン領域(\ref{sec:NoCodePage}節を参照)の操作ボタンを生成、および、表示を切り替える処理である。
操作ボタンは固定的なUI要素ではなく、ユーザの操作状況に応じて動的に構成する。本処理により、
ユーザが現在実行可能な操作を直感的に把握できるようにする。

操作ボタンの生成および配置には、
.NET MAUI(\ref{sec:NET_MAUI}節を参照)が提供する
\texttt{Microsoft.\allowbreak Maui.\allowbreak Controls} 名前空間のUIコンポーネントを用いる。
具体的には、\texttt{Button} クラスを配置するための \texttt{Layout} コンテナを使用する。

本処理は、
ユーザ操作対応部が保持する、現在の表示パターンを決定する変数である、表示パターンフラグを参照し、表示パターンフラグに基づいて
対応する操作ボタンを生成、および、描画する。

表示パターンフラグは、以下に示す3つのbool値の状態変数の組み合わせである。
\begin{itemize}
      \item \texttt{IsScreenListAddButtonVisible}
      \item \texttt{IsClassAllButtonVisible}
      \item \texttt{IsClassAddButtonVisible}
\end{itemize}

操作ボタンの表示パターンは、\ref{sec:GUI-operation-control-function}節で説明した「表示パターンA」から「表示パターンD」の4つである。表示パターンフラグと表示パターンの対応関係を、表\ref{tab:button_appear}に示す。

本処理の流れを、以下に示す。

\begin{enumerate}
  \item ユーザ操作対応部が管理する、表示パターンフラグの現在の値を取得する。
  
  \item 取得した表示パターンフラグをもとに、表\ref{tab:button_appear}の対応関係に応じて表示する表示パターンを決定する。
  
  \item 決定した表示パターンに基づき、
  \texttt{Button} クラスのインスタンスを動的に生成する。
  各ボタンには、ユーザ操作対応部が保持する、編集コマンド(\ref{sec:UOM_EditCommand}節を参照)を関連付ける。
  操作ボタン領域の操作ボタンと編集コマンドの対応表を、表\ref{tab:Command}に示す。
  
  \item 生成した操作ボタン集合を、
  ツール上部の操作ボタン領域に配置する。
  配置には \texttt{StackLayout}の
  Layoutコンテナを用い、既存のボタンが存在する場合は
  一度削除した上で再配置する。

  \item ユーザが操作ボタンを押下すると、関連付けている編集コマンドをユーザ操作対応部へ出力する。
  
  \item 表示パターンフラグを更新するたびに、
  本処理を再実行することで、
  操作ボタンの表示内容を更新する。
\end{enumerate}

\begin{table}[tp]
  \centering
  \caption{表示パターンフラグと表示方法の対応関係}
  \label{tab:button_appear}
  \begin{tabular}{|c|c|c|c|}
    \hline
    \rule{0pt}{4.5ex}\textbf{表示パターン} &
    \textbf{\shortstack{IsScreenList\\AddButtonVisible}} &
    \textbf{\shortstack{IsClassAll\\ButtonVisible}} &
    \textbf{\shortstack{IsClassAdd\\ButtonVisible}} \\
    \hline
    表示パターンA & false & false & false \\
    \hline
    表示パターンB & true & false & false \\
    \hline
    表示パターンC & false & true & false \\
    \hline
    表示パターンD & false & false & true \\
    \hline
  \end{tabular}
\end{table}

\begin{table}[tp]
  \centering
  \caption{操作ボタンと編集コマンドの対応}
  \label{tab:Command}
  \begin{tabular}{|c|c|}
    \hline
    \textbf{操作ボタン} &
    \textbf{編集コマンド} \\
    \hline
    画面の追加 & 画面追加 \\
    \hline
    ボタンの追加 & ボタン追加 \\
    \hline
    イベントの追加 & イベント追加 \\
    \hline
    タイムアウトの追加 & タイムアウト追加 \\
    \hline
    削除 & 削除 \\
    \hline
    フォルダの選択 & フォルダ選択 \\
    \hline
    クラス名(画面名)の変更 & クラス名(画面名)変更  \\
    \hline
  \end{tabular}
\end{table}


\subsection{フォルダツリー描画処理}\label{sec:FolderTree}
フォルダツリー描画処理は、「GUI操作による\VDM 仕様編集ページ」のフォルダツリー表示領域(\ref{sec:NoCodePage}節を参照)に、
フォルダとファイル名をツリー形式で描画する処理である。
本処理の入力は、ユーザ操作対応部が保持する\texttt{FolderItems}である。
\texttt{FolderItems}は、
フォルダツリーの各行を表すデータ構造である\texttt{FolderItem}
のコレクションである。
\texttt{FolderItem}のデータ構造を、表\ref{tb:FolderItem}に示す。
\texttt{FolderItem}は、フォルダまたはファイルの絶対パスである\texttt{FullPath}を持ち、
それの表示名である\texttt{Name}、フォルダかファイルかを判定する\texttt{IsFolder}、\texttt{IsFile}、ルートフォルダからどれだけ下の階層かを表す\texttt{Level}を保持する。
さらに、展開状態を制御する\texttt{IsExpanded}、および、可視状態を制御する\texttt{IsVisible} を保持する。
\begin{table}[tp]
\centering
\caption{FolderItemデータ構造}
\label{tb:FolderItem}
\begin{tabular}{|l|l|p{9cm}|}
\hline
\textbf{属性名} & \textbf{型} & \textbf{説明} \\
\hline
Name & string & フォルダまたはファイルの名前 \\
\hline
FullPath & string & フォルダまたはファイルの絶対パス \\
\hline
Level & int & ルートからの階層レベル(インデント表示に利用) \\
\hline
IsExpanded & bool & ツリー表示における展開状態を表す真偽値\\
\hline
IsVisible & bool & ツリー表示における可視状態を表す真偽値\\
\hline
IsFolder & bool & フォルダであることを示す真偽値 \\
\hline
IsFile & bool & ファイルであることを示す真偽値 \\
\hline
\end{tabular}
\end{table}

描画部は、ユーザ操作対応部が保持する\texttt{FolderItems} の各要素\texttt{FolderItem}が保持する
階層情報\texttt{Level}、展開状態\texttt{IsExpanded}、可視状態\texttt{IsVisible}、
および種別情報\texttt{IsFolder}、\texttt{IsFile}に基づき、表示内容を構成する。
本処理では、.NET MAUI(\ref{sec:NET_MAUI}節を参照)が提供する
\texttt{CollectionView} を用いてフォルダツリーを表示する。
\texttt{CollectionView} は項目集合を縦方向に一覧表示するUIコンポーネントであり、
本研究ではツリー構造を一次元リストとして表現することで、
フォルダツリー表示を実現している。
本処理では、.NET MAUIのデータバインディング機構を用いて
可視状態と表示内容の更新を行う。

本処理の流れを、以下に示す。

\begin{enumerate}
  \item 入力の受け取り

  ユーザ操作対応部から\texttt{FolderItems}を受け取る。

  \item 表示要素の生成

  \texttt{FolderItems} を上から順に走査し、各\texttt{FolderItem}に対して表示用のUI要素を生成する。
 
  \item アイコンおよびラベルの決定

  \texttt{FolderItem.IsFolder}が\texttt{true}の要素にはフォルダアイコンを付与し、
  \texttt{FolderItem.\allowbreak IsFile}が\texttt{true}の要素にはアイコンの付与を行わない。
  表示名は\texttt{FolderItem.\allowbreak Name}を用い、ラベル文字列として描画する。
  フォルダの場合は、\texttt{FolderItem.\allowbreak IsExpanded}の値に応じて
  展開、および、折りたたみを切り替える。

  \item 可視状態の反映

   各表示行の可視状態は、\texttt{FolderItem.\allowbreak IsVisible}によって判定する。
  \texttt{false} の場合、対応する行は \texttt{CollectionView}コンポーネント上で非表示とする。
  これにより、フォルダの展開、および、折りたたみ操作に伴う表示の更新を、\texttt{CollectionView}コンポーネントの再描画処理のみで反映できる。

  \item ユーザによる選択検知

\texttt{CollectionView}コンポーネントの、ユーザが選択した各行を、検知する\texttt{TapGestureRecognizer}クラスにより、ユーザによるフォルダツリー内の\texttt{FolderItem}の選択を検知する。
  検知した\texttt{FolderItem}を、ユーザ操作対応部のフォルダツリー操作対応処理(\ref{sec:UOM_FolderTree}節を参照)へ出力する。

  \item 表示更新

  \texttt{FolderItems} の内容を変更した場合には、
  .NET MAUIのデータバインディング機構によりユーザ操作対応部の\texttt{FolderItems}をデータバインディングしているため、
  フォルダツリー表示を自動的に更新する。
  これにより、フォルダ構造の変更や選択状態の更新を、即座にフォルダツリー領域へ反映できる。
\end{enumerate}

\subsection{\VDM 描画処理}\label{sec:DrawVDM}
\VDM 描画処理は、「GUI操作による\VDM 仕様編集ページ」の\VDM 仕様表示領域(\ref{sec:NoCodePage}節を参照)に
ユーザ操作対応部が保持する\VDM の文字列である
\texttt{VdmContent}を、\VDM 仕様表示領域に描画する処理である。

描画部は、ユーザ操作対応部が保持する\texttt{VdmContent}を受け取り、編集対象とするMarkdown仕様に対応した\VDM の文字列を描画する。

本処理では、.NET MAUI(\ref{sec:NET_MAUI}節を参照)が提供する
テキスト表示用 UI コンポーネントを用いて\VDM 仕様表示領域に\texttt{VdmContent}を描画する。
また、.NET MAUIのデータバインディング機構を用いて、表示の更新を行う。

本処理の流れを、以下に示す。

\begin{enumerate}
  \item 入力の受け取り

  ユーザ操作対応部から、
  ユーザ操作対応部が保持する\VDM の文字列である\texttt{VdmContent}を取得する。

  \item 表示領域の初期化

 .NET MAUI 標準のテキスト表示用 UI コンポーネントである
  \texttt{Editor}の内容を空にし、\VDM 仕様表示領域の表示状態を初期化する。

  \item \VDM 文字列の描画

  1.で取得した \texttt{VdmContent} を、
  \texttt{Editor}コンポーネントの \texttt{Text} プロパティに設定する。
  これにより、
  改行やインデントを保持したまま表示できる。

  \item \VDM 文字列の更新

  \texttt{VdmContent} の内容を更新した場合には、
  .NET MAUIのデータバインディング機構によりユーザ操作対応部の\texttt{VdmContent}をデータバインディングしているため、
  \texttt{Editor}コンポーネントの\texttt{Text}プロパティを自動的に更新する。
  これにより、\VDM 文字列の更新を、即座に\VDM 仕様表示領域へ反映できる。
\end{enumerate}

\subsection{メニューバー描画処理}
\label{sec:MenuBarDrawing}

メニューバー描画処理は、「GUI操作による\VDM 仕様編集ページ」のページ上部のメニューバー(\ref{sec:NoCodePage}節を参照)に、
フォルダ選択、および、新規ファイル作成の操作項目を配置し、
ユーザ操作対応部の編集コマンド実行処理(\ref{sec:UOM_EditCommand}節を参照)へ編集コマンドを出力する処理である。

本処理では、メニューバーを実装するために、.NET MAUI(\ref{sec:NET_MAUI}節を参照)が提供する\texttt{Microsoft.\allowbreak Maui.\allowbreak Controls}のメニューバー関連コンポーネントを用いる。
具体的には、\texttt{MenuBarItem}コンポーネント、および、\texttt{MenuFlyoutItem}コンポーネントを用いてメニューバーの項目を定義し、各項目にコマンドを割り当てる。

本処理の流れを、以下に示す。

\begin{enumerate}
\item メニューバーの配置

\texttt{MenuBarItem}コンポーネントを用いてメニューバーを構成し、
\texttt{MenuFlyoutItem}コンポーネントを用いて「フォルダ選択」、および、「新規ファイル作成」をメニューバーに配置する。

\item コマンドの関連付け

「フォルダ選択」に編集コマンドのフォルダ選択、および、「新規ファイル作成」に編集コマンドの新規ファイル作成を、それぞれ結び付ける。

\item メニューバー操作の検知

\texttt{Microsoft.\allowbreak Maui.\allowbreak Controls}がユーザによるメニューバー項目選択を検知した場合、当該項目に割り当てたコマンドを、
ユーザ操作対応部の編集コマンド実行処理へ出力する。

\end{enumerate}

\subsection{CTM領域描画処理}\label{sec:CTMArea}

CTM領域描画処理は、「GUI操作による\VDM 仕様編集ページ」のCTM領域
(\ref{sec:NoCodePage}節を参照)にCTMを表示するための表示枠を構成し、
CTM描画処理(\ref{sec:CreateCTM}節を参照)で生成したCTMを表示するとともに、
CTM領域上でのユーザ操作を検知する処理である。

本処理では、CTM領域を縦横スクロール可能な表示領域として構成するため、
\texttt{Microsoft.\allowbreak Maui.\allowbreak Controls}名前空間(\ref{sec:NET_MAUI}節を参照) が提供する \texttt{ScrollView} コンポーネントを用いて
CTM表示用の表示枠を構成する。
この表示枠の内部には、CTMの表示およびユーザ操作検知機能を担う
\texttt{ContentView} コンポーネントを配置する。

この\texttt{ContentView}コンポーネントは、
CTM描画用の\texttt{GraphicsView}コンポーネントを内部に配置し、
当該\texttt{GraphicsView}コンポーネントの\texttt{Drawable}プロパティに
\texttt{IDrawable}インターフェースを用いたCTM描画処理を設定することで、
CTM の表示機能を実現する。

また、CTM描画処理で生成するCTMのレイアウトに基づき、
CTM領域を縦横スクロール可能な表示領域として構成するため、
\texttt{ScrollView} コンポーネントにCTMの描画範囲を配置し、CTM全体をスクロール操作で閲覧可能とする。


また、\texttt{ContentView}コンポーネントは、CTM領域上で発生するユーザ操作を検知するため、
\texttt{WinUI}ライブラリのイベントを用いて、
左クリック操作、
ドラッグ操作、および右クリック操作を検知する。
検知後、受け取ったポインタ座標および操作内容を、ユーザ操作対応部へ通知する。
なお、ポインタ座標はCTM領域左上を基準座標
($(x, y) = (0, 0)$) とする。 

  本処理では、「GUI操作による\VDM 仕様編集ページ」のCTM領域部分に\texttt{ScrollView}コンポーネント、および、\texttt{ContentView}コンポーネントを配置し、
  CTM表示用の表示枠を構成する。

  以降、\texttt{ContentView}コンポーネントのCTMの描画およびユーザ操作検知機能について、説明する。

  \begin{itemize}
      \item CTMの描画
      
      \begin{enumerate}

      \item CTM描画処理を実行し、CTMのレイアウトを生成する。

      \item 描画領域サイズの初期設定 

      CTM描画処理が生成したCTMのレイアウトに基づき、
      描画領域の横幅、および、縦幅を設定し、
      \texttt{ScrollView}コンポーネントによりCTM領域をスクロール可能な状態とする。

      \item 描画領域サイズの更新
  
      CTM描画処理でCTMのレイアウトを変更した場合、.NET MAUIの標準ライブラリの\texttt{GraphicsView.SizeChanged}イベントにより、CTM描画処理で確定したCTMのレイアウトを検知し、
      \texttt{ScrollView}コンポーネントのスクロール可能な範囲を更新する。

      \end{enumerate}

      \item ユーザ操作の検知

      CTM領域上での左クリック、ドラッグ、および右クリック操作は、
      描画領域要素が保持する入力検知機構により検知する。
      本処理では、\texttt{WinUI} が提供するポインタ入力イベントを用いて、
      入力位置とユーザによる操作種別を検知する。

      ユーザによる各操作種別ごとの検知方法を、以下に示す。
      \begin{itemize}

      \item 左クリック操作

      左クリック操作は、\texttt{WinUI}が提供する
      \texttt{PointerPressed}イベントによりポインタ座標を検知し、
      \texttt{PointerEventArgs}イベントにより左ボタンクリックを検知した場合、
      左クリック位置の座標 $(x, y)$ を入力として受け取る。
      その後、左クリック位置の座標と左クリックであることをユーザ操作対応部の左クリック操作対応処理(\ref{sec:UOM_Click}節を参照)へ出力する。

      \item ドラッグ操作

      ドラッグ操作は、
      \texttt{WinUI}が提供する
      \texttt{PointerPressed}イベント、\texttt{PointerMoved}イベント、\texttt{PointerReleased}イベント、
      \texttt{PointerEventArgs}イベント
      の各イベントを用いる。
      \texttt{PointerPressed} イベントによりポインタ座標を検知し、\texttt{PointerEventArgs}イベントにより左ボタンクリックを検知した場合、
      押下位置のポインタ座標 $(x_0, y_0)$ を取得し、取得した座標を直前の座標$(x_b, y_b)$として保持し、
      押下開始としてユーザ操作対応部へ通知する。
      押下状態のままポインタが移動したことを\texttt{PointerMoved}イベントにより検知した場合、押下状態のままのポインタが解放されたことを\texttt{PointerReleased}イベントにより検知するまで、
      以下に示す処理を行う。
      \begin{enumerate}[label=\roman*]
        \item 現在座標 $(x, y)$ を取得する。
        \item 現在座標 $(x, y)$ と直前の座標$(x_b, y_b)$との差分 $(\Delta x, \Delta y)$ を算出する。
        \item ドラッグ中であること、および、$(\Delta x, \Delta y)$を移動量としてユーザ操作対応部へ出力する。
        \item 直前の座標$(x_b, y_b)$を、現在座標 $(x, y)$ で更新する。
      \end{enumerate}
      \texttt{PointerReleased} イベントを検知した場合、
      解放位置の座標 $(x_r, y_r)$を取得し、
      ドラッグ終了としてユーザ操作対応部のドラッグ移動操作対応処理(\ref{sec:UOM_Drag}節を参照)へ出力する。

      \item 右クリック操作

      右クリック操作では、
      \texttt{WinUI}が提供する
      \texttt{PointerPressed} イベントによりポインタ座標を検知し、
      \texttt{PointerEventArgs} イベントにより右ボタンクリックを検知した場合、
      右クリック位置の座標 $(x, y)$ を入力として受け取る。
      その後、右クリック位置の座標と右クリックであることをユーザ操作対応部の右クリック操作対応処理(\ref{sec:UOM_Context}節を参照)へ出力する。
      \end{itemize}
\end{itemize}

\subsection{CTM描画処理}
\label{sec:CreateCTM}

CTM描画処理は、CTM領域上にCTMを図として描画する処理である。本処理は、ユーザ操作対応部が保持する、CTM領域に表示する各CTM要素のデータを格納した
\texttt{GUIElement} のリストである \texttt{elements}を受け取り、CTM領域上にCTMを図として描画する。
本処理では、CTM要素の種類(以降、CTM要素種別と呼ぶ)に応じて、形状、寸法、および描画スタイルを適用し、CTMを図として描画する。

ここで、\texttt{GUIElement} は、各CTM 要素を構成する構造データである。\texttt{GUIElement}のデータ構造を、表\ref{tb:GUIElement}に示す。
\texttt{GUIElement}では、各CTM要素種別を\texttt{Type}属性として保持する。\texttt{Type}属性は、列挙型である\texttt{GuiElementType}型のデータである。
\texttt{GuiElementType}型の要素を、以下に示す。
\begin{itemize}
      \item \texttt{Screen}：画面要素
      \item \texttt{Button}：ボタン要素
      \item \texttt{Event}：イベント要素
      \item \texttt{Timeout}：タイムアウト要素
\end{itemize}

分岐イベント要素は、\texttt{GUIElement}の\texttt{Branches}属性に、分岐条件と分岐条件成立時のイベントを格納するデータ構造である\texttt{EventBranch}を用いてデータを保持する。
\texttt{EventBranch}のデータ構造を、表\ref{tb:EventBranch}に示す。

\begin{table}[tp]
\centering
\caption{GUIElementデータ構造}
\label{tb:GUIElement}
\begin{tabular}{|c|c|c|}
\hline
\textbf{属性名} & \textbf{型} & \textbf{説明}\\ 

\hline
Type & GuiElementType & CTM要素種別(Screen, Button, Event, Timeout) \\

\hline
Name & string & CTM要素の名称 \\

\hline
Target & string & 遷移先となるCTM要素名 \\

\hline
X & float & CTM領域上での X 座標 \\

\hline
Y & float & CTM領域上での Y 座標 \\

\hline
Width & float & CTM要素の横幅 \\
  
\hline
Height & float & CTM要素の高さ \\

\hline
IsSelected & bool & 選択状態 \\

\hline
IsMovable & bool & ドラッグによる移動が可能かどうか \\

\hline
Branches & List\textless EventBranch \textgreater & 条件分岐を表す分岐リスト \\


\hline
IsBranch & bool & Branchesを保持しているかどうか \\

\hline
\end{tabular}
\end{table}

\begin{table}[tp]
\centering
\caption{EventBranchデータ構造}
\label{tb:EventBranch}
\begin{tabular}{|l|l|p{10cm}|}
\hline
\textbf{属性名} & \textbf{型} & \textbf{説明}\\ 
\hline
Condition & string & 分岐条件 \\

\hline
Target & string & 分岐条件成立時のイベント \\
\hline
\end{tabular}
\end{table}

本処理では、GUI要素生成部(\ref{sec:GUIElementGenerationComponent}節を参照)で定義する初期配置規則に基づき、
\texttt{GuiElementType}型の要素、および、\texttt{Branches}属性をもつ要素について、
それぞれ表\ref{tab:gui_node_spec}、表\ref{tab:gui_node_branch}に示す
描画仕様を適用する。

\begin{table}[tp]
\centering
\caption{GuiElementType型の要素の描画仕様}
\label{tab:gui_node_spec}
\begin{tabular}{|l|l|l|c|c|p{4.5cm}|}
\hline
\textbf{GUIElement.Type} & \textbf{形状} & \textbf{色} & \textbf{横幅(Px)} & \textbf{高さ(Px)} & \textbf{配置・備考} \\
 \hline
Screen
& 角丸矩形
&紫& 160 & 45
& CTM領域の左列に縦配置(間隔80Px)、移動可 \\
 \hline

Button
& 楕円
&青& 80 & 45
& CTM領域の左列に縦配置(間隔80Px)、移動可 \\
 \hline

Event
& 矩形
&緑& 160 & 45
& CTM領域の右列に縦配置(間隔80Px)、条件分岐時は本体非表示、移動可 \\
 \hline

Timeout
& 楕円
&ピンク& 112 & 45
&規定オフセットとして、左上(x = 40Px, y = 8Px)固定配置、移動不可 \\
 \hline
\end{tabular}
\end{table}

\begin{table}[tp]
\centering
\caption{\texttt{Branches}属性をもつ要素の可視ノードの描画仕様}
\label{tab:gui_node_branch}
\begin{tabular}{|c|c|c|c|c|c|}
\hline
\textbf{GUIElement.Banches} & \textbf{形状} & \textbf{色} & \textbf{横幅(px)} & \textbf{高さ(px)} & \textbf{備考} \\
 \hline
Condition
& 菱形
&青& 176 & 50
& 分岐条件を表す可視ノード \\
 \hline

Target
& 矩形
&緑& 152 & 36
& 分岐先イベントを示すノード \\
 \hline
\end{tabular}
\end{table}

CTM生成処理は、
.NET MAUI(\ref{sec:NET_MAUI}節を参照)が提供する
\texttt{GraphicsView} および \texttt{IDrawable} を用いて実装する。
具体的には、
\texttt{IDrawable.Draw()} メソッド内で、
\texttt{Microsoft.Maui.Graphics} が提供する描画コンテキスト
\texttt{ICanvas} を用いて、
ノード、ラベル、および遷移矢印を描画する。

また、本処理では、
描画した各CTM要素に対応する、各CTM要素が画面上に占める領域を表す表示属性
である外接矩形に関する情報を格納した\texttt{BRectangle}のリスト\texttt{HitRegions}を生成、および、保持し、
ヒットテスト処理(\ref{sec:UOM_HitTest}節を参照)に利用する。
\texttt{BRectangle}のデータ構造を、表\ref{tab:hit_test_rect}に示す。

\begin{table}[tp]
\centering
\caption{BRectangleのデータ構造}
\label{tab:hit_test_rect}
\begin{tabular}{|c|c|p{8cm}|}
\hline
\textbf{属性} & \textbf{型} & \textbf{説明} \\
\hline
Element & GUIElement &
当該外接矩形に対応するCTM要素。 \\
\hline
X & float &
外接矩形の左上 X 座標。 \\
\hline
Y & float &
外接矩形の左上 Y 座標。\\
\hline
W & float &
外接矩形の横幅。\\
\hline
H & float &
外接矩形の縦幅。\\
\hline
ZIndex & int &
描画順序を表す値。
ヒットテスト処理(\ref{sec:UOM_HitTest}節を参照)で複数の外接矩形を検出した場合に、前面要素を判定するために用いる。 \\
\hline
BranchIndex& int &
GUIElementが保持するBranches属性をもつ場合、分岐条件の順序を表す添字。\\
\hline
\end{tabular}
\end{table}

本処理の流れを、以下に示す。

\begin{enumerate}

      \item 入力を受け取る
      
      ユーザ操作対応部から、CTM要素のリストである\texttt{elements}を受け取る。

      \item 描画領域の初期化 
       
      \texttt{ICanvas} を用いて描画領域を初期化する。
      具体的には、描画しているCTM要素や矢印を消去し、
      線幅、フォントサイズ、描画色を初期化する。

      \item \texttt{HitRegions}の生成
      
      空のリストである\texttt{HitRegions}を生成する。

      \item CTM要素の走査  

      ユーザ操作対応部から受け取った\texttt{elements} を順に走査し、
      各\texttt{GUIElement}について\texttt{GUIElement.Type}を参照して
      CTM要素種別を判定する。判定後、以下の処理をすべてのCTM要素について繰り返す。

      \begin{enumerate}[label=\alph*.]
      \item ノード形状および描画スタイルの決定  

      CTM要素種別に応じて、
      画面要素およびイベント要素は矩形、
      タイムアウト要素は楕円と矩形、
      分岐イベント要素は菱形と矩形として、描画する。
      各CTM要素が保持する座標 \texttt{GUIElement.X}、\texttt{GUIElement.Y} を左上座標とし、
      規定の幅 \texttt{GUIElement.W}、高さ \texttt{GUIElement.H} を用いてノード形状を描画する。

      \item ラベルの描画  
      
      各CTM要素が保持する文字列 \texttt{GUIElement.Name}を用いて、
      ラベル文字列は、ノードの中心座標
      $(\texttt{GUIElement.X} + \frac{\texttt{GUIElement.W}}{2}, \texttt{GUIElement.Y} + \frac{\texttt{GUIElement.H}}{2})$ を基準として配置する。

      \item 遷移矢印の描画  

      接続元CTM要素および接続先CTM要素の\texttt{GUIElement.X}、\texttt{GUIElement.Y}、\texttt{GUIElement.W}、\texttt{GUIElement.H}を用いて、
      接続元CTM要素の右辺中央を開始点、
      接続先CTM要素の左辺中央を終了点として
      矢印を描画する。

      矢印の開始点および終了点は、接続元CTM要素および接続先CTM要素の\texttt{BRectangle}をもとに算出する。
      具体的には、接続元CTM要素の右端中央を開始点とし、接続先CTM要素の左端中央を終了点とする。
      ここで、接続元CTM要素の左上座標を$(X_s, Y_s)$、幅を$W_s$、高さを$H_s$、
      接続先CTM要素の左上座標を$(X_t, Y_t)$、幅を$W_t$、高さを$H_t$とすると、
      開始点$(x_s, y_s)$および終了点$(x_t, y_t)$は、式\ref{eq:arrow_points_start}、と式\ref{eq:arrow_points_end}によりそれぞれ算出できる。

      \begin{equation}\label{eq:arrow_points_start}
            (x_s, y_s) = (X_s + W_s, Y_s + \frac{H_s}{2})
      \end{equation}

      \begin{equation}\label{eq:arrow_points_end}
            (x_t, y_t) = (X_t, Y_t + \frac{H_t}{2})
      \end{equation}

      \item 分岐イベント要素の描画  

      分岐イベント要素については、
      親イベント要素本体は描画せず、
      \texttt{Branches} に含む各分岐条件を
      独立した描画単位として展開する。
      親イベント要素とは、\texttt{Branches}を保持しているイベント要素(\texttt{GUIElement.Type == Event})のことである。

      分岐条件の描画手順を、以下に示す。

      \begin{enumerate}[label=\roman*.]
            \item 基準Y座標の算出

            分岐条件配置の基準となるY座標は、
            対応するボタン要素の中心Y座標を用いる。

            対応ボタン要素の\texttt{GUIElement.X}、\texttt{GUIElement.Y}の左上座標を $(X_b, Y_b)$、
            ノード高さ\texttt{GUIElement.H}を $H$ とすると、
            基準となる中心Y座標 $Y_{\mathrm{anchor}}$ は、
            式\ref{eq:center}により算出できる。

            \begin{equation}\label{eq:center}
            Y_{\mathrm{anchor}} = Y_b + \frac{H}{2}
            \end{equation}

            \item 同じ親イベント要素の分岐イベント要素全体の高さの算出

            同じ親イベント要素の分岐イベント要素の個数を $n$、
            各分岐イベント要素の縦方向の間隔を $S$、
            各分岐イベント要素のノードの高さを$H_{\mathrm{branch}}$ とすると、
            同じ親イベント要素の分岐イベント要素全体の高さ $H_{\mathrm{total}}$ は、
            式\ref{eq:totalhight}により算出できる。

            \begin{equation}\label{eq:totalhight}
            H_{\mathrm{total}} = n \cdot H_{\mathrm{branch}} + (n - 1) \cdot S
            \end{equation}

            \item 分岐条件配置の基準上端の算出

            同じ親イベント要素に対応するすべての分岐イベント要素が
            基準中心 $Y_{\mathrm{anchor}}$ に対して
            上下対称となるように配置するため、
            分岐条件群の上端Y座標 $Y_{\mathrm{top}}$ は、
            式\ref{eq:topY}により算出できる。

            \begin{equation}\label{eq:topY}
            Y_{\mathrm{top}} = Y_{\mathrm{anchor}} - \frac{H_{\mathrm{total}}}{2}
            \end{equation}

            \item 各分岐条件の配置位置の算出

            $i$ 番目の分岐条件($i = 0, 1, \dots, n-1$)の
            中心Y座標 $Y^{(i)}_{\mathrm{center}}$ は、
            式\ref{eq:centerY}により算出できる。

            \begin{equation}\label{eq:centerY}
            Y^{(i)}_{\mathrm{center}} =
            Y_{\mathrm{top}} + \frac{H_{\mathrm{branch}}}{2} + i \cdot (H_{\mathrm{branch}} + S)
            \end{equation}

            分岐条件の左上座標 $Y^{(i)}$ は、
            中心座標から高さの半分を引くことで決定する。
            $Y^{(i)}$ は、式\ref{eq:yi}により算出できる。

            \begin{equation}\label{eq:yi}
            Y^{(i)} = Y^{(i)}_{\mathrm{center}} - \frac{H_{\mathrm{branch}}}{2}
            \end{equation}

            \item 分岐先イベント要素の配置決定

            分岐先イベント要素が存在する場合、
            その縦方向位置は対応する分岐条件の中心に揃える。
            分岐先イベント要素の左上Y座標 $Y^{(i)}_t$ は、
            式\ref{eq:YT}により算出できる。

            \begin{equation}\label{eq:YT}
            Y^{(i)}_t = Y^{(i)}_{\mathrm{center}} - \frac{H_{\mathrm{branch}}}{2}
            \end{equation}

            横方向位置については、
            分岐条件要素の右側に配置する固定列を用いて配置する。

            \item 分岐番号の保持

            各分岐条件は、ユーザによるCTM領域上での選択対象であるため、
            菱形および分岐条件のラベルを包含する外接矩形を生成し、
            親イベント要素および分岐番号 $i$ と対応付けて保持する。
            分岐番号 $i$ は、
            \texttt{Branches} の走査における添字として決定し、
            \texttt{BRectangle}を保持するデータ構造に
            \texttt{BranchIndex}(整数)として格納する。
            これにより、ユーザ操作対応部は
            外接矩形に含まれるポインタ座標から
            $(\text{親イベント要素}, i)$ を特定できる。
            条件分岐ではない他の要素は、\texttt{BranchIndex}に$-$1を格納する。
      \end{enumerate}

      \item \texttt{BRectangle}の記録  

      描画ノードについて、
      \texttt{BRectangle}を記録し、\texttt{HitRegions}に追加する。

\end{enumerate}

\item \texttt{HitRegions}の出力

\texttt{HitRegions}を、ユーザ操作対応部に出力する。

      \item 選択状態の強調表示  

      ユーザ操作対応部により選択中と判定した要素については、
      \texttt{GUIElement.IsSelected}をもとに、
      枠線の色をオレンジ色に変更し、
      枠線の太さを1DIPから3DIPに変更することで
      選択状態を強調表示する。
\end{enumerate}




\subsection{コンテキストメニュー描画処理}
\label{sec:Context}

コンテキストメニュー描画処理は、ユーザ操作対応部より操作対象のCTM要素種別、および、分岐イベント要素かそれ以外かを受け取り、
CTM領域の中央にコンテキストメニューを描画する。
コンテキストメニュー描画後に、ユーザの選択結果に応じた編集コマンドをユーザ操作対応部へ出力する。

本処理では、.NET MAUIの標準ライブラリである
\texttt{Microsoft.\allowbreak Maui.\allowbreak Controls}
が提供する \texttt{Shell.\allowbreak Current.\allowbreak DisplayActionSheet}メソッドを用いて、
コンテキストメニューをアクションシートとして表示する。
表示する項目は、右クリック位置の操作対象CTM要素種別に応じて切り替える。

本処理の流れを、以下に示す。
\begin{enumerate}

      \item 入力の受け取り

      ユーザ操作対応部から操作対象のCTM要素種別、および、分岐条件かどうかを受け取る。

  
      \item メニュー項目の決定

      ユーザ操作対応部から受け取った操作対象のCTM要素種別、および、
      分岐条件かどうかに基づき、
      表示するメニュー項目の集合を決定する。
      例えばボタン要素には「イベント追加」、「コピー」、「貼り付け」、「ボタン名変更」、および、「削除」をメニュー項目の集合に追加し、
      イベント要素には「イベント変更」、および、「削除」をメニュー項目の集合に追加する。

      \item コンテキストメニューの表示

      \texttt{Microsoft.\allowbreak Maui.\allowbreak Controls}ライブラリ が提供する
      \texttt{Shell.\allowbreak Current.\allowbreak DisplayActionSheet}メソッドを呼び出し、
      画面上にアクションシートを表示する。
      \texttt{Shell.\allowbreak Current.\allowbreak DisplayActionSheet}メソッドにより、
      ユーザが選択した項目名を取得する。

      \item 選択結果の通知
      
      取得した項目名に基づき、
      対応する編集コマンドを、
      ユーザ操作対応部の編集コマンド実行処理(\ref{sec:UOM_EditCommand}節を参照)へ通知する。
\end{enumerate}


\subsection{ダイアログ描画処理}
\label{sec:Dialog}

ダイアログ描画処理は、ユーザ操作対応部より、表示するダイアログの種類を受け取り、
確認、エラー通知、および、各編集コマンドに対応したダイアログを、
ユーザへ表示する。
ダイアログ表示後、ユーザによる選択、および、入力を、ユーザ操作対応部へ返す。

本処理で用いるメソッドは、
\texttt{Microsoft.\allowbreak Maui.\allowbreak Controls}ライブラリの\texttt{DisplayAlert}メソッド、\texttt{DisplayPrompt}メソッド、および、\texttt{DisplayActionSheet}メソッド、
\texttt{CommunityToolkit.\allowbreak Maui.\allowbreak Views}ライブラリの\texttt{Popup}コンポーネントである。

本処理の流れを、以下に示す。
\begin{enumerate}
  \item 入力の受け取り

  ユーザ操作対応部から編集コマンドに応じた表示するダイアログの種類を受け取る。
  
  \item ダイアログの表示

  ユーザ操作対応部から受け取った編集コマンドに応じたダイアログを表示する。
  表示するダイアログは、以下の4種類のダイアログに分類する。
  \begin{itemize}
      \item 通知用ダイアログ
      
      \texttt{Microsoft.\allowbreak Maui.\allowbreak Controls}ライブラリの\texttt{DisplayAlert}メソッドを用いて、
      通知項目を表示し、ユーザの選択を入力として受け取るダイアログ。

      \item 複数項目選択用ダイアログ

      \texttt{Microsoft.\allowbreak Maui.\allowbreak Controls}ライブラリの\texttt{DisplayActionSheet}メソッドを用いて、
      複数の選択項目を表示し、ユーザの選択を受け取るダイアログ。

      \item 単一項目入力ダイアログ

      \texttt{Microsoft.\allowbreak Maui.\allowbreak Controls}ライブラリの\texttt{DisplayPrompt}メソッドを用いて、
      1つの記入欄を表示し、ユーザの入力を受け取るダイアログ。

      \item 複数項目入力ダイアログ

      \texttt{CommunityToolkit.Maui.Views}ライブラリの\texttt{Popup}コンポーネントを用いて、
      複数の記入欄、および、選択項目を表示し、ユーザの入力、および、選択を受け取るダイアログ。

  \end{itemize}
  \item 編集コマンド実行処理への返却

  受け取ったユーザの選択、および、入力を、ユーザ操作対応部の編集コマンド実行処理(\ref{sec:UOM_EditCommand}節を参照)へ返す。
\end{enumerate}



\section{ユーザ操作対応部}\label{sec:UserOperationMonitoring}

ユーザ操作対応部は、描画部(\ref{sec:DrawingComponent}節を参照)よりユーザの操作、および、編集コマンドを受け取り、
プロジェクト管理部(\ref{sec:ProjectManagementComponent}節を参照)、および、
描画部の各処理へ、各命令を行う統括処理部である。
本処理部は、MVVMにおけるView層とModel層間の橋渡しとして振る舞う。

本処理部の処理は、以下の7つである。
\begin{itemize}
      \item 左クリック操作対応処理(\ref{sec:UOM_Click}節を参照)
      \item ヒットテスト処理(\ref{sec:UOM_HitTest}節を参照)
      \item 右クリック操作対応処理(\ref{sec:UOM_Context}節を参照)
      \item 左ダブルクリック操作対応処理(\ref{sec:UOM_DoubleClick}節を参照)
      \item ドラッグ移動操作対応処理(\ref{sec:UOM_Drag}節を参照)
      \item フォルダツリー操作対応処理(\ref{sec:UOM_FolderTree}節を参照)
      \item 編集コマンド実行処理(\ref{sec:UOM_EditCommand}節を参照)
\end{itemize}

ユーザ操作対応部が保持する主要なデータを、表\ref{tab:uom_data}に示す。

\begin{table}[tp]
  \centering
  \caption{ユーザ操作対応部が保持するデータ}
  \label{tab:uom_data}
  \begin{tabularx}{\textwidth}{|c|c|X|}
    \hline
    \textbf{データ名} & \textbf{型} & \textbf{説明・参照先} \\
    \hline
    elements & List\textless GUIElement\textgreater & CTM要素のリスト (\ref{sec:CreateCTM}節を参照) \\
    \hline
    HitRegions & List\textless BRectangle\textgreater & ヒットテスト用領域リスト (\ref{sec:CTMArea}節を参照) \\
    \hline
    FolderItems & List\textless FolderItem\textgreater & フォルダツリー表示用データ (\ref{sec:FolderTree}節を参照) \\
    \hline
    VdmContent & string & VDM仕様文字列 (\ref{sec:DrawVDM}節を参照) \\
    \hline
    SelectedElement & GUIElement & 選択中CTM要素 (\ref{sec:UOM_Click}節、\ref{sec:UOM_HitTest}節を参照) \\
    \hline
    \begin{tabular}{c}IsScreenListAddButtonVisible\\IsClassAllButtonVisible\\IsClassAddButtonVisible\end{tabular} 
    & bool & 表示パターンフラグ (\ref{sec:DrawingComponent_OperationButtons}節を参照) \\
    \hline
    Xs, Ys & float & 左クリックによるポインタ座標 (\ref{sec:UOM_Click}節を参照) \\
    \hline
    LastClickTime & DateTime & 直前のクリック時刻 (\ref{sec:UOM_DoubleClick}節を参照) \\
    \hline
    CopiedElement & CopiedElement & コピー・切り取りされた要素 (\ref{sec:UOM_EditCommand}節を参照) \\
    \hline
    LastClickElement & GUIElement & 直前のクリック対象要素 (\ref{sec:UOM_DoubleClick}節を参照) \\
    \hline
  \end{tabularx}
\end{table}

以降、各ユーザ操作に対応する処理を説明する。

\subsection{左クリック操作対応処理}\label{sec:UOM_Click}
左クリック操作対応処理は、描画部のCTM領域描画処理(\ref{sec:CTMArea}節を参照)による左クリックによるポインタ座標を受け取り、
対象CTM要素の選択状態\texttt{GUIElement.\allowbreak IsSelected}を更新する処理である。
入力は描画部からの左クリック座標、出力は対象CTM要素の選択状態の更新、および、描画部のCTM描画処理(\ref{sec:DrawingComponent}節を参照)の呼び出しである。

本処理の流れを、以下に示す。
\begin{enumerate}
  \item 描画部から左クリック動作であること、および、ポインタ座標 $(x, y)$ を取得する。
  \item ポインタ座標 $(x, y)$ を、ユーザ操作対応部で保持する変数Xs、Ysとして保持する。
  \item ユーザ操作対応部が保持する、操作対象CTM要素を表す状態変数\texttt{SelectedElement}に既にCTM要素を格納している場合
  、\texttt{SelectedElement}のCTM要素の選択状態 \texttt{GUIElement.IsSelected} を \texttt{false} に更新する。
  \item ヒットテスト処理(\ref{sec:UOM_HitTest}節を参照)へ、左クリックによるポインタ座標を渡し、\texttt{SelectedElement} を確定する。
  \item \texttt{SelectedElement} の \texttt{GUIElement.IsSelected} を \texttt{true} に更新する。
  \item 描画部のCTM描画処理を呼び出し、CTMを描画する。
  \item 左ダブルクリック操作対応処理(\ref{sec:UOM_DoubleClick}節を参照)を呼び出し、左ダブルクリック判定を行う。
\end{enumerate}

\subsection{ヒットテスト処理}\label{sec:UOM_HitTest}
ヒットテスト処理は、ユーザのクリックによるポインタ座標を受け取り、ユーザの操作座標がどのCTM要素に該当するかを判定し、
操作対象のCTM要素を確定する処理である。
本処理は、描画部が生成し、ユーザ操作対応部が保持する\texttt{HitRegions}を用いて、ポインタ座標が外接矩形内に存在するかどうかを判定する。

ユーザのクリックによるポインタ座標 $(x, y)$ が矩形内に存在するかどうかは、
式\ref{eq:hit}により判定する。式中のX、Y、W、および、Hは、表\ref{tab:hit_test_rect}に示した属性である。

\begin{equation}\label{eq:hit}
X \leq x \leq X + W \;\land\; Y \leq y \leq Y + H
\end{equation}

本処理の流れを、以下に示す。
\begin{enumerate}
  \item ユーザのクリックによるポインタ座標を受け取る。   
  \item \texttt{HitRegions}を先頭から末尾まで走査し、式\ref{eq:hit}により包含判定を行う。
  \item CTM要素の一部が重なっており、複数のCTM要素がユーザのクリックによるポインタ座標に該当する場合は、描画順序(前面優先)に基づき最前面CTM要素を採用する。
      描画順序は、\texttt{BRectangle}の \texttt{ZIndex} 属性を参照し、値が大きいCTM要素ほど前面に描画していると判定する。
  \item 採用したCTM要素をユーザ操作対応部で状態変数\texttt{SelectedElement}として保持する。
  \item 包含判定により該当するCTM要素が存在しない場合、\texttt{SelectedElement} を \texttt{null} に設定する。
\end{enumerate}

\subsection{右クリック操作対応処理}\label{sec:UOM_Context}

右クリック操作対応処理は、描画部からユーザの右クリックによるポインタ座標を受け取り、
対象CTM要素種別、および、分岐イベント要素かそれ以外かを、コンテキストメニュー描画処理へ出力する処理である。

本処理の流れを、以下に示す。
\begin{enumerate}
  \item 描画部から右クリック動作であること、および、ポインタ座標$(x, y)$を受け取る。
  \item ヒットテスト処理へ、ポインタ座標を渡し、\texttt{SelectedElement}を確定する。
  \item \texttt{SelectedElement}のCTM要素種別\texttt{GUIElement.\allowbreak Type}、および、条件分岐の有無\texttt{IsBranch}を抽出する。
  \item CTM要素種別、および、分岐イベント要素かそれ以外かを、描画部のコンテキストメニュー描画処理へ出力する。
\end{enumerate}

\subsection{左ダブルクリック操作対応処理}\label{sec:UOM_DoubleClick}
左ダブルクリック操作対応処理は、画面要素に対する左クリックを判定し、
短時間に同一要素に対し2回クリックを検出した場合に左ダブルクリックとして確定し、
プロジェクト管理部の画面切り替え処理(\ref{sec:PM_ScreenTransitionProcess}節を参照)へ、対象とする画面要素の名称\texttt{GUIElement.Name} を出力する。
本処理の目的は、CTM 上の 画面要素を起点として、対応する画面クラスへ遷移することである。

ユーザ操作対応部では、直前の左クリック情報として「直前クリック時刻\texttt{LastClickTime}」と「直前クリック対象要素\texttt{LastClickElement}」を保持する。
本研究では、ダブルクリック判定の閾値を 400 msとする。
なお、時刻取得には.NET(\ref{sec:NET}節を参照)標準ライブラリの協定世界時刻(UTC)
に基づく現在時刻を取得する静的プロパティである\texttt{DateTime.UtcNow} を用いて、\texttt{LastClickElement}との差分を計算する。

本処理の流れを、以下に示す。
\begin{enumerate}
  \item 左クリック操作対応処理(\ref{sec:UOM_Click}節を参照)から呼び出しを受け、\texttt{SelectedElement}を参照する。
  \item \texttt{SelectedElement} が画面要素(\texttt{GUIElement.Type == Screen})である場合のみ、ダブルクリック判定対象とする。
        画面要素以外をクリックした場合は、ダブルクリック判定用の情報である
        「\texttt{LastClickTime}」、および、「\texttt{LastClickElement}」に\texttt{null}を設定し、シングルクリックとして扱う。
  \item 画面要素であった場合、現在時刻を\texttt{DateTime.UtcNow}(UTC)より取得し、
        \texttt{LastClickElement}が同一CTM要素であること、および、
        現在時刻と\texttt{LastClickTime}の時刻の差分が閾値400 ms以内であることを共に満たすかを判定する。
      \begin{itemize}
  \item 上記2つの条件を共に満たす場合、左ダブルクリックとして確定し、
        プロジェクト管理部の画面切り替え処理(\ref{sec:PM_ScreenTransitionProcess}節を参照)へ、対象とする画面要素の名称\texttt{GUIElement.Name} を出力する。
        なお、確定後は誤検出防止のため、\texttt{LastClickTime}と\texttt{LastClickElement}を\texttt{null}で初期化する。
  \item 上記2つの条件を共に満たさない場合はシングルクリックとして扱い、
        \texttt{LastClickTime}を現在時刻、
        \texttt{LastClickElement}を\texttt{SelectedElement}として保持情報を更新する。
      \end{itemize}

\end{enumerate}

\subsection{ドラッグ操作対応処理}\label{sec:UOM_Drag}
ドラッグ操作対応処理は、描画部から受け取るポインタのドラッグ操作を判定し、
CTM要素の配置変更を反映する処理である。
入力は、押下開始座標、ポインタ移動量、および、解放座標であり、
出力は、描画部(\ref{sec:DrawingComponent}節を参照)のCTM描画処理の呼び出し、更新後のCTM要素座標情報、および、プロジェクト管理部のファイル更新処理の呼び出しである。

本処理では、ユーザが CTM 要素上で左クリック押下を行い、
その状態のままポインタを移動させた場合に、ドラッグ操作として扱う。

本処理の流れを、以下に示す。
\begin{enumerate}
  \item 描画部から、ドラッグ操作を行っていること、および、ポインタの移動量を受け取る。
  \item \texttt{SelectedElement}の\texttt{GUIElement.IsMovable} を参照し、移
  動不可(\texttt{IsMovable == false})である場合は、処理を終了する。
  \item ドラッグ開始時点における CTM 要素の座標 $(X, Y)$ と、
  押下開始座標(Xs,Ys)との差分を、オフセット量 $(\Delta x, \Delta y)$ として保持する。
  以降、描画部からドラッグ終了を受け取るまで以下を繰り返す。
  \begin{enumerate}[label=\roman*.]
  
      \item ポインタ移動イベントごとに、押下開始座標(Xs,Ys)に移動量を加算する。
      
      \item 移動量を加算した押下開始座標(Xs,Ys)から、
      オフセット量 $(\Delta x, \Delta y)$ を差し引くことで、
      新しい CTM 要素座標 $(X', Y')$ を算出する。
      
      \item $(X', Y')$を用いて、\texttt{SelectedElement}の\texttt{GUIElement.X} および \texttt{GUIElement.Y} を更新する。
      
      \item 座標更新のたびに、描画部の
      CTM描画処理を呼び出し、CTM領域上に移動結果を即時反映する。
  \end{enumerate}

  \item ポインタ解放時に、最終的な CTM 要素座標(\texttt{GUIElement.X}, \texttt{GUIElement.Y})を確定する。
  
  \item プロジェクト管理部のファイル更新処理(\ref{sec:FileUpdateProcess}節を参照)を呼び出す。
\end{enumerate}


\subsection{フォルダツリー操作対応処理}\label{sec:UOM_FolderTree}
フォルダツリー操作対応処理は、描画部からユーザによるフォルダツリー表示領域での\texttt{FolderItem}に対するクリック操作を受け取り、
フォルダの展開、折りたたみ、
および、編集対象ファイルの切り替えを行う処理である。
本処理は、
プロジェクト管理部のファイル読込処理
  (\ref{sec:PM_FileLoadProcess}節を参照)、および、描画部のCTM描画処理(\ref{sec:CreateCTM}節を参照)を呼び出す。

本処理の流れを、以下に示す。
\begin{enumerate}
  \item 描画部よりユーザが選択した\texttt{FolderItem}を受け取る。

  \item ユーザが選択した\texttt{FolderItem}を \texttt{SelectedItem} として保持する。
      \begin{itemize}
  
      \item \texttt{SelectedItem}の\texttt{IsFile}が\texttt{true}である場合は、
        プロジェクト管理部のファイル読込処理を呼び出し、編集対象ファイルを更新する。
        編集対象ファイルを更新した際、プロジェクト管理部から\texttt{elements}を受け取り、描画部のCTM描画処理を呼び出す。
  
      \item \texttt{SelectedItem}の\texttt{IsFolder}が\texttt{true}である場合は、フォルダの展開、および、折りたたみを行う。
      その際、\texttt{IsExpanded}の値を反転し、配下の\texttt{FolderItems}について\texttt{IsVisible}の値を反転する。
      これにより、展開時は子要素を表示し、折りたたみ時は子要素を非表示とする。
      \end{itemize}
\end{enumerate}

\subsection{編集コマンド実行処理}\label{sec:UOM_EditCommand}

編集コマンド実行処理は、コンテキストメニュー、操作ボタン領域の操作ボタン、メニューバーにより確定した編集コマンドを実行し、
必要な入力値(名称、遷移先、条件文等)をダイアログで取得した上で、
CTM要素リストを更新する処理である。

本処理は、編集コマンドの種類を入力として受け取り、
\texttt{elements}に、要素の追加、更新、削除を行った上で、更新後の\texttt{elements}、描画部のCTM描画処理の呼び出し、
プロジェクト管理部のファイル更新処理の呼び出し、および、新規ファイル作成処理の呼び出しを行う。

編集コマンドは、CommunityToolkit.Mvvm(\ref{sec:MVVM}節を参照)の\texttt{RelayCommand} で定義する。

本処理の流れを、以下に示す。

\begin{enumerate}
  \item 編集コマンドの種類と、選択中CTM要素\texttt{SelectedElement}を受け取る。

  \item 編集コマンドの種類に応じて、ダイアログ描画処理を呼び出してダイアログを表示する。
  例えば、ボタン追加ではボタン追加ダイアログ、削除では削除確認ダイアログを描画部のダイアログ描画処理を呼び出して表示する。
  \begin{itemize}
    \item キャンセルした場合は、処理を中断し、\texttt{elements}を変更しない。
    \item 入力値が空、もしくは重複する場合は、エラー表示を行い、中断する。
  \end{itemize}

  \item 編集コマンドの種類に応じて\texttt{elements}を更新する。
  編集コマンドの種類に応じた処理を、以下に示す。
  \begin{itemize}
      \item \textbf{画面追加}：
      \begin{enumerate}[label=\roman*]
            \item ユーザによる入力を受け取る。
            \item \texttt{elements}を先頭から走査し、既存画面要素名と重複する場合は追加しない。
            \item 新しい画面要素(\texttt{Type\allowbreak ==\allowbreak Screen, Name\allowbreak ==\allowbreak 画面要素名})である\texttt{GUIElement}を生成し、\texttt{elements}に追加する。
            \item プロジェクト管理部のファイル更新処理(\ref{sec:FileUpdateProcess}節を参照)を呼び出し、ファイルの更新を行う。
            \item 描画部のCTM描画処理(\ref{sec:CreateCTM}節を参照)を呼び出し、CTMの再描画を行う。
      \end{enumerate}
      \item \textbf{ボタン追加}：
      \begin{enumerate}[label=\roman*]
            \item ユーザによる入力を受け取る。
            \item \texttt{elements}を先頭から走査し、既存ボタン名と重複する場合は追加しない。
            \item 新しいボタン要素(\texttt{Type\allowbreak ==\allowbreak Button, Name\allowbreak ==\allowbreak ボタン名})である\texttt{GUIElement}を生成し、\texttt{elements}に追加する。
            \item プロジェクト管理部のファイル更新処理を呼び出し、ファイルの更新を行う。
            \item 描画部のCTM描画処理を呼び出し、CTMの再描画を行う。
      \end{enumerate}
      \item \textbf{イベント追加}：
      \begin{enumerate}[label=\roman*]
            \item ユーザによる入力を受け取る。
            \item 対象のボタン要素に対して、すでにイベントが存在する場合は、描画部にエラー表示用のダイアログに対してダイアログ描画処理を呼び出し、対象のボタン要素にイベントを追加しない。
            \item 描画部に分岐イベント選択用のダイアログに対してダイアログ描画処理を呼び出し、入力を受け取り、単一イベント、または、分岐イベントを選択する。
            \begin{itemize}
                  \item 単一イベント選択時：
                  \begin{enumerate}[label=\alph*]
                        \item 描画部に単一イベント追加用のダイアログに対してダイアログ描画処理を呼び出し、入力を受け取り、イベント内容を取得する。
                        \item 新しいイベント要素(\texttt{Type\allowbreak ==\allowbreak Event})である\texttt{GUIElement}を生成し、\texttt{elements}に追加する。
                        このとき、取得したイベント内容を生成した\texttt{GUIElement}の\texttt{Name}、\texttt{Target}、および、対象ボタン要素の\texttt{GUIElement}の\texttt{Target}に保持し、
                        描画部が矢印接続を構成できるようにする。
                        \item プロジェクト管理部のファイル更新処理を呼び出し、ファイルの更新を行う。
                  \end{enumerate}
                  \item 分岐イベント選択時：
                  \begin{enumerate}[label=\alph*]
                        \item 描画部に分岐イベント追加用のダイアログに対してダイアログ描画処理を呼び出し、入力を受け取り、
                        分岐条件文と分岐先イベントを取得する。
                        \item 新しい分岐イベント要素(\texttt{Type\allowbreak ==\allowbreak Event, Branches\allowbreak ==\allowbreak null})である\texttt{GUIElement}を生成し、\texttt{elements}に追加する。
                        このとき、分岐条件を\texttt{Condition}、分岐先イベントを\texttt{Target}として\texttt{EventBranch}を生成し、生成した\texttt{GUIElement}の\texttt{Branches}に格納する。また、対象ボタン要素の\texttt{GUIElement}の\texttt{Target}に「\texttt{"対象ボタン名"}押下」を保持し、
                        描画部が条件分岐表示を構成できるようにする。
                        \item プロジェクト管理部のファイル更新処理を呼び出し、ファイルの更新を行う。
                  \end{enumerate}
            \end{itemize}
            \item 描画部のCTM描画処理を呼び出し、CTMの再描画を行う。
      \end{enumerate}
      \item \textbf{タイムアウト追加}：
      \begin{enumerate}[label=\roman*]
            \item ユーザによる入力を受け取る。
            \item 新しいタイムアウト要素(\texttt{Type \allowbreak == \allowbreak Timeout})と、タイムアウト要素に対応したイベント要素(\texttt{Type \allowbreak ==\allowbreak  Event})である\texttt{GUIElement}を生成し、
            \texttt{elements}に追加する。タイムアウトは1画面につき1つであるため、既存のタイムアウト要素が存在する場合は更新(上書き)する。
            \item プロジェクト管理部のファイル更新処理を呼び出し、ファイルの更新を行う。
            \item 描画部のCTM描画処理を呼び出し、CTMの再描画を行う。
      \end{enumerate}

      \item \textbf{削除}：
      \begin{enumerate}[label=\roman*]
            \item ユーザが削除をキャンセルした場合は、処理を中断し、\texttt{elements}を変更しない。
            \item ユーザが削除を確認した場合は、\texttt{elements}から対象要素の\texttt{GUIElement}を除去する。
            \item ボタン要素を削除する場合、当該ボタン要素を対象とするイベント要素も同時に削除する。
            \item プロジェクト管理部のファイル更新処理を呼び出し、ファイルの更新を行う。
            \item 描画部のCTM描画処理を呼び出し、CTMの再描画を行う。
      \end{enumerate}

      \item \textbf{編集}：
      \begin{enumerate}[label=\roman*]
            \item 対象CTM要素種別を判定する。
            \item 対象CTM要素種別に応じて、描画部に編集用のダイアログに対してダイアログ描画処理を呼び出し、入力を受け取る。
            \item ユーザが編集を完了した場合、入力値を\texttt{elements}内の対象要素(\texttt{GUIElement})に反映する。
            \item 反映後の名称が既存要素と重複する場合は処理を実行しない。
            \item プロジェクト管理部のファイル更新処理を呼び出し、ファイルの更新を行う。
            \item 描画部のCTM描画処理を呼び出し、CTMの再描画を行う。
      \end{enumerate}

      \item \textbf{フォルダ選択}：
      \begin{enumerate}[label=\roman*]
            \item Windows.Storage.Pickers(\ref{sec:Windows.Storage.Pickers}節を参照)を用いてフォルダ選択インターフェースを表示し、
            プロジェクトフォルダのパス\texttt{folder.path}を取得する。
            \item プロジェクト管理部のフォルダ選択処理(\ref{sec:PM_SelectFolder}節を参照)を呼び出し、\texttt{folder.path}を渡す。
            \item プロジェクト管理部から\texttt{FolderItems}を受け取り、ユーザ操作対応部内で保持している\texttt{FolderItems}を更新する。
      \end{enumerate}

      \item \textbf{新規ファイル作成}：
      \begin{enumerate}[label=\roman*]
            \item ユーザによる入力を受け取る。
            \item 取得したファイル名が\texttt{FolderItems}内に存在していないかどうか探索する。
            \item \texttt{FolderItems}内に同一のファイル名が存在する場合、描画部にエラー表示用のダイアログに対してダイアログ描画処理を呼び出し、処理を中断する。
            \item \texttt{FolderItems}内に同一のファイル名が存在しない場合は、プロジェクト管理部のファイル作成処理(\ref{sec:PM_FileCreate}節を参照)を呼び出し、ファイルを作成する。
            \item プロジェクト管理部から\texttt{FolderItems}を受け取り、ユーザ操作対応部内で保持している\texttt{FolderItems}を更新する。
      \end{enumerate}

            \item \textbf{クラス名(画面名)変更}：
      \begin{enumerate}[label=\roman*]
            \item ユーザによる入力を受け取る。
            \item ユーザ操作対応部が保持する\texttt{elements}の画面クラスのクラス名(以降、画面クラス名と呼ぶ)(\texttt{GUIElement.Type\allowbreak  ==\allowbreak  Screen})の\texttt{GUIElement}の\texttt{Name}を取得したクラス名(画面名)で更新する。
            \item プロジェクト管理部のファイル更新処理を呼び出し、ファイルの更新を行う。
            \item 描画部のCTM描画処理を呼び出し、CTMの再描画を行う。
      \end{enumerate}

      \item \textbf{コピー}：
      \begin{enumerate}[label=\roman*]
            \item 選択中CTM要素\texttt{SelectedElement}を参照し、コピー対象を確定する。
            \item \texttt{SelectedElement}が\texttt{null}の場合は、中断する。
            \item コピー対象の\texttt{GUIElement}を複製し、ユーザ操作対応部が保持する\texttt{SelectedElement}のコピー用バッファ\texttt{CopiedElement}へ格納する。\texttt{CopiedElement}のデータ構造を、表\ref{tab:copy-data}に示す。また、コピー処理を以下に示す。
            
            \begin{table}[tp]
                  \centering
                  \caption{\texttt{CopiedElement}のデータ構造}
                  \label{tab:copy-data}
                  \begin{tabularx}{\textwidth}{|l|l|X|}
                  \hline
                      \textbf{属性名} & \textbf{型} & \textbf{説明} \\
                      \hline
                      Type & GuiElementType & コピー元のType属性の値(SelectedElement.Type) \\
                      \hline
                      Name & string & コピー元のName属性の値(SelectedElement.Name) \\
                      \hline
                      EventNameKey & string & ボタンのTarget属性の値(SelectedElement.Target) \\
                      \hline
                  \end{tabularx}
            \end{table}

            \begin{itemize}
                  \item \texttt{SelectedElement}が画面要素の場合:
                  \begin{enumerate}[label=\alph*]
                        \item \texttt{CopiedElement.Type}に\texttt{SelectedElement.Type}の値をコピーする。
                        \item \texttt{CopiedElement.Name}に\texttt{SelectedElement.Name}の値をコピーする。
                  \end{enumerate}
                  \item \texttt{SelectedElement}がボタン要素の場合:
                  \begin{enumerate}[label=\alph*]
                        \item \texttt{CopiedElement.Type}に\texttt{SelectedElement.Type}の値をコピーする。
                        \item \texttt{CopiedElement.Name}に\texttt{SelectedElement.Name}の値をコピーする。
                        \item \texttt{CopiedElement.EventNameKey}に\texttt{SelectedElement.Target}の値をコピーする。
                  \end{enumerate}
            \end{itemize}
            \item コピー結果の通知として、描画部に通知用ダイアログに対してダイアログ描画処理を呼び出し、ユーザに通知する。
      \end{enumerate}

      \item \textbf{貼り付け}：
      \begin{enumerate}[label=\roman*]
            \item ユーザ操作対応部が保持する\texttt{CopiedElement}を参照し、データの有無を判定する。
            \item \texttt{CopiedElement}が\texttt{null}の場合は、描画部にエラー表示用のダイアログに対してダイアログ描画処理を呼び出し、ユーザに通知する。
            \item \texttt{CopiedElement}から新規要素\texttt{GUIElement}を生成し、\texttt{elements}へ追加する。
            このとき、名称重複を回避するため、描画部に名称変更用のダイアログに対してダイアログ描画処理を呼び出し、同一名称である要素を追加しないようにする。
            貼り付け処理は以降に詳しく説明する。
            \item プロジェクト管理部のファイル更新処理を呼び出し、ファイルの更新を行う。
            \item 描画部のCTM描画処理を呼び出し、CTMの再描画を行う。
      \end{enumerate}

  \end{itemize}

\end{enumerate}

\subsubsection{貼り付け処理}
貼り付け処理は、ユーザがコピー済みの CTM 要素を複製する処理である。
ユーザ操作対応部は、コピー用バッファ\texttt{CopiedElement}の内容を参照し、新しい要素名を確定し、要素の生成および配置を行う。
貼り付け処理は編集コマンド実行処理の一部である。

処理の流れを以下に示す。
\begin{itemize}
      \item \texttt{CopiedElement}が画面要素の場合:
      \begin{enumerate}
            \item 新しい画面要素\texttt{GUIElement.\allowbreak Type \allowbreak == \allowbreak Screen}を生成する。各属性は以下の設定をする。
            \begin{itemize}
            \item \texttt{GUIElement.\allowbreak Name}にユーザ操作から受け取った名称を設定する。
            \item \texttt{GUIElement.\allowbreak Target}に\texttt{null}を設定する。
            \item \texttt{GUIElement.\allowbreak X}に貼り付け位置であるX座標$Xs$を設定する。
            \item \texttt{GUIElement.\allowbreak Y}に貼り付け位置であるY座標$Ys + 30$を設定する。
            \item \texttt{GUIElement.\allowbreak Width}に160を設定する。
            \item \texttt{GUIElement.\allowbreak Height}に45を設定する。
            \item \texttt{GUIElement.\allowbreak IsMovable}に\texttt{true}を設定する。
            \item \texttt{GUIElement.\allowbreak IsSelected}に\texttt{false}を設定する。
            \item \texttt{GUIElement.\allowbreak IsBranch}に\texttt{false}を設定する。 
            \end{itemize}
            \item \texttt{elements}に格納する
      \end{enumerate}
      \item \texttt{CopiedElement}がボタン要素の場合:
      \begin{enumerate}
            \item \texttt{GUIElement.\allowbreak Type\allowbreak  ==\allowbreak  Event}かつ\texttt{GUIElement.\allowbreak Name}が\texttt{CopiedElement.\allowbreak EventNameKey}に該当するイベント要素を\texttt{elements}から探索し、存在した場合、以下の処理を行う。存在しない場合は以下の処理を行わず3.の処理に進む
            \begin{itemize}
                  \item \texttt{GUIElement.\allowbreak IsBranch\allowbreak  ==\allowbreak  true}の場合:
                  \begin{enumerate}[label =\roman*]
                        \item 新しいイベント要素\texttt{GUIElement.\allowbreak Type \allowbreak == \allowbreak Event}を生成し、以下の設定を行う。
                        \begin{itemize}
                              \item \texttt{GUIElement.\allowbreak Name}に\texttt{\textless ユーザから受け取った名称\textgreater へ}を設定。
                              \item \texttt{GUIElement.\allowbreak Target}に\texttt{null}を設定する。
                              \item \texttt{GUIElement.\allowbreak X}に貼り付け位置であるX座標$Xs + 240$を設定する。
                              \item \texttt{GUIElement.\allowbreak Y}に貼り付け位置であるY座標$Ys + 30$を設定する。
                              \item \texttt{GUIElement.\allowbreak IsMovable}に\texttt{true}を設定する。
                              \item \texttt{GUIElement.\allowbreak IsSelected}に\texttt{false}を設定する。
                              \item \texttt{GUIElement.\allowbreak IsBranch}に\texttt{true}を設定する。  
                        \end{itemize}
                        \item コピー元の\texttt{Branches}を基に、新しい\texttt{Branches}リストを生成する。
                        具体的には、コピー元の\texttt{Branches}の分岐条件\texttt{Condition}の順序iに応じて\texttt{条件コピーi}を設定する。
                        また、コピー元の\texttt{Branches}の各分岐先イベント\texttt{Target}の順序kに応じて\texttt{分岐コピーkへ}を設定する。
                  \end{enumerate}
                        \item \texttt{GUIElement.\allowbreak IsBranch\allowbreak  ==\allowbreak  false}の場合:
                        新しいイベント要素\texttt{GUIElement.\allowbreak Type \allowbreak == \allowbreak Event}を生成し、以下の設定を行う。
                        \begin{itemize}
                              \item \texttt{GUIElement.\allowbreak Name}に\texttt{コピーへ}を設定。
                              \item \texttt{GUIElement.\allowbreak Target}に\texttt{コピーへ}を設定する。
                              \item \texttt{GUIElement.\allowbreak X}に貼り付け位置であるX座標の$Xs + 240$を設定する。
                              \item \texttt{GUIElement.\allowbreak Y}に貼り付け位置であるY座標の$Ys + 30$を設定する。
                              \item \texttt{GUIElement.\allowbreak IsMovable}に\texttt{true}を設定する。
                              \item \texttt{GUIElement.\allowbreak IsSelected}に\texttt{false}を設定する。
                              \item \texttt{GUIElement.\allowbreak IsBranch}に\texttt{false}を設定する。  
                        \end{itemize}
            \end{itemize}
                  \item 新しく生成したイベント要素を\texttt{elements}に格納する
                  \item 新しいボタン要素\texttt{GUIElement.Type\allowbreak  ==\allowbreak  Button}を生成する。
                  \begin{itemize}
                        \item \texttt{GUIElement.Name}にユーザ操作から受け取った名称を設定する。
                        \item \texttt{GUIElement.\allowbreak Target}に、新しく生成したイベント要素の\texttt{Name}を設定する。
                        \item \texttt{GUIElement.X}に貼り付け位置であるX座標の$Xs$を設定する。
                        \item \texttt{GUIElement.Y}に貼り付け位置であるY座標の$Ys + 30 $を設定する。
                        \item \texttt{GUIElement.Width}に80を設定する。
                        \item \texttt{GUIElement.Height}に45を設定する。
                        \item \texttt{GUIElement.IsMovable}に\texttt{true}を設定する。
                        \item \texttt{GUIElement.IsSelected}に\texttt{false}を設定する。
                        \item \texttt{GUIElement.IsBranch}に\texttt{false}を設定する。
                  \end{itemize}
                  \item 新しく生成したボタン要素を\texttt{elements}に格納する

      \end{enumerate}
\end{itemize}


\section{プロジェクト管理部}\label{sec:ProjectManagementComponent}

本処理部のシステム構成を、図\ref{fig:proj-system}に示す。
\begin{figure}[tp]
  \centering
  \includegraphics[width=1.0\linewidth]{./images/proj-system.png}
  \caption{プロジェクト管理部のシステム構成図}
  \label{fig:proj-system}
\end{figure}

本処理部は、以下の6つの処理から構成する。
\begin{itemize}
  \item フォルダ選択処理(\ref{sec:PM_SelectFolder}節を参照)
  \item フォルダおよびファイル探索処理(\ref{sec:PM_FolderFileSearch}節を参照)
  \item ファイル読込処理(\ref{sec:PM_FileLoadProcess}節を参照)
  \item ファイル更新処理(\ref{sec:FileUpdateProcess}節を参照)
  \item 画面切り替え処理(\ref{sec:PM_ScreenTransitionProcess}節を参照)
  \item 新規ファイル作成処理(\ref{sec:PM_FileCreate}節を参照)
\end{itemize}

プロジェクト管理部が保持する主要なデータを、表\ref{tab:pm_data}に示す。

\begin{table}[tp]
  \centering
  \caption{プロジェクト管理部が保持するデータ}
  \label{tab:pm_data}
  \begin{tabularx}{\textwidth}{|c|c|X|}
    \hline
    \textbf{データ名} & \textbf{型} & \textbf{説明} \\
    \hline
    SelectedFolderPath & string & 選択プロジェクトフォルダパス (\ref{sec:PM_SelectFolder}節を参照) \\
    \hline
    SelectedFilePath & string & 選択ファイルパス (\ref{sec:PM_FileLoadProcess}節を参照) \\
    \hline
    MarkdownText & string & Markdown文字列 (\ref{sec:PM_FileLoadProcess}節を参照) \\
    \hline
    ScreenIndex & Dictionary\textless string, string\textgreater & 画面索引辞書 (\ref{sec:PM_FolderFileSearch}節を参照) \\
    \hline
  \end{tabularx}
\end{table}

本処理部の入力は、ユーザ操作対応部(\ref{sec:UserOperationMonitoring}節を参照)による\texttt{elements}、および、プロジェクトフォルダのデータである。
出力は、解析部、および、変換部へ渡すMarkdown仕様の文字列(以降、Markdown文字列と呼ぶ)、GUI要素生成部へ渡すCTM要素配置データ、\texttt{elements}、および、
プロジェクトフォルダへ出力する各ファイル(Markdown仕様ファイル、VDM++仕様ファイル、CTM要素配置データファイル)である。
CTM要素配置データには、CTM要素の名称(\texttt{GUIElement.\allowbreak Name})とCTM領域での配置情報(\texttt{GUIElement.X} , \texttt{GUIElement.Y})を含み、
Markdown仕様の記述ルール(\ref{sec:Specrule}節を参照)に含まない配置情報のみを保持する。CTM要素配置データの構造を、リスト\ref{lst:JSON_data}に示す。

\begin{figure}[tp]
\begin{lstlisting}[caption={CTM要素の配置情報を示すCTM要素配置データの構造}, label={lst:JSON_data}, language={}]
[
  {
    "Name": "GUIElement.Name",
    "X": "GUIElement.X",
    "Y": "GUIElement.Y"
  }
]
\end{lstlisting}
\end{figure}

プロジェクト管理部は、ユーザが選択するプロジェクト(フォルダ配下のMarkdown仕様ファイル)の状態を管理し、
解析部(\ref{sec:ParsingComponent}節を参照)、および、変換部(\ref{sec:ConversionComponent}節を参照)へ渡す入力データ(Markdown文字列)、
およびGUI要素生成部(\ref{sec:GUIElementGenerationComponent}節を参照)へ渡すCTM要素配置データを準備するとともに、
ユーザによる編集結果をプロジェクトフォルダへ出力する処理部である。
本処理部でのファイルシステムの入出力には 、System.IO (\ref{sec:NET}節を参照)を用いる。

以降、各処理について説明する。


\subsection{フォルダ選択処理}\label{sec:PM_SelectFolder}

フォルダ選択処理は、ユーザが編集対象のプロジェクトフォルダを選択した際に、
選択フォルダの絶対パスを取得してプロジェクト管理部で保持する状態変数 \texttt{ SelectedFolderPath} に保持し、
フォルダおよびファイル探索処理(\ref{sec:PM_FolderFileSearch}節を参照)を実行して
ツリー表示用データ \texttt{FolderItems} を構築する処理である。

本処理では、
System.IO
(\ref{sec:NET}節を参照)を用いて、
フォルダおよびファイルの列挙処理を行う。

本処理の流れを、以下に示す。

\begin{enumerate}
  \item 入力の受け取り

  ユーザ操作対応部からプロジェクトフォルダのパス\texttt{folder.Path}を受け取り、
  本処理を実行する。

  \item 選択フォルダパスを内部状態として保持

  \texttt{folder.Path} が空でない場合、
  1.で取得した\texttt{folder.Path}を
  \texttt{SelectedFolderPath}に代入し、
  選択フォルダパスとして\texttt{SelectedFolderPath} をプロジェクト管理部が保持する。

  \item フォルダおよびファイル探索処理の呼び出し

  フォルダおよびファイル探索処理を呼び出し、
  \texttt{SelectedFolderPath} 配下のフォルダおよび
  Markdown 仕様ファイルを走査して
  ツリー表示用データ構造である
  \texttt{FolderItems} を生成する
  (\ref{sec:PM_FolderFileSearch}節を参照)。
  なお、\texttt{FolderItems} はユーザ操作対応部へ渡し、
  ユーザ操作対応部が保持する。

\end{enumerate}

\subsection{フォルダおよびファイル探索処理}\label{sec:PM_FolderFileSearch}

フォルダおよびファイル探索処理は、フォルダ選択処理または、新規ファイル作成処理より、呼び出しを受け、
選択したプロジェクトフォルダ配下のフォルダ、および、Markdown仕様ファイルを探索する。
本処理ではプロジェクトフォルダ内に存在する、フォルダ、および、ファイルを表現するデータ構造である\texttt{FolderItem}を構築する。
その後、\texttt{FolderItem}のコレクションである
\texttt{FolderItems} を構築する。

本処理では、
System.IO
(\ref{sec:NET}節を参照)を用いて、
フォルダおよびファイルの列挙を行う。

本処理の流れを、以下に示す。

\begin{enumerate}
  \item 探索処理の初期化

  選択フォルダパス\texttt{SelectedFolderPath} が空でないことを確認した後、
  空の\texttt{FolderItems} を生成する。空だった場合には、エラーを返す。

  \item \texttt{SelectedFolderPath} 配下の要素の探索

  \texttt{SelectedFolderPath} 配下のフォルダおよびファイルを探索する。
  フォルダと Markdown仕様ファイルのみを探索対象とし、
  それ以外のファイルは対象外とする。

  フォルダの要素を探索する処理の流れを、以下に示す。

  \begin{enumerate}[label=\roman*.]
  \item フォルダおよびファイル要素の登録

  \begin{itemize}
      \item フォルダの場合
      
  発見した各フォルダについて、
   \texttt{IsFolder} が \texttt{True} の\texttt{FolderItem} を生成する。生成の際、プロジェクトフォルダ直下(\texttt{FolderItem.Level == 0})の場合、
   \texttt{FolderItem.IsVisible}を\texttt{True}にし、
  プロジェクトフォルダ直下でない(\texttt{FolderItem.Level != 0})場合、
  \texttt{FolderItem.IsVisible}を\texttt{false}にする。
  その後、すべてのフォルダの\texttt{FolderItem.IsExpanded}を\texttt{false}にする。
  \texttt{FolderItem}を生成した後、生成した\texttt{FolderItem}を\texttt{FolderItems} に追加する。
  

  \item Markdown仕様ファイルの場合

  発見した 各Markdown仕様ファイルについて、
  \texttt{IsFile} が \texttt{True}の \texttt{FolderItem} を生成する。フォルダの場合と同様に、プロジェクトフォルダ直下(\texttt{FolderItem.Level == 0})の場合、\texttt{FolderItem.IsVisible}を\texttt{True}にし、
  プロジェクトフォルダ直下でない(\texttt{FolderItem.Level != 0})場合、\texttt{FolderItem.IsVisible}を\texttt{false}にする。
  \texttt{FolderItem}を生成した後、生成した\texttt{FolderItem}を\texttt{FolderItems} に追加する。
  \end{itemize}

  \item 画面索引辞書(\texttt{ScreenIndex})の設定

      発見した各 Markdown仕様ファイルについて、画面クラス名から当該ファイルを特定するために、
      画面索引辞書(\texttt{ScreenIndex})へ対応関係を登録する。
      登録にあたり、Markdown 文字列の先頭行を取得し、
      「\texttt{\# 画面一覧}」である場合は画面管理クラスとして扱うため索引登録を行わない。
      一方で、先頭行が「\texttt{\#\#}」で始まる場合は画面クラスとして扱い、
      先頭行から抽出した画面クラス名をキー、Markdown仕様ファイルの絶対パスを値として登録する。
      \texttt{ScreenIndex} はプロジェクト管理部が保持し、
      画面切り替え処理(\ref{sec:PM_ScreenTransitionProcess}節を参照)で利用する。

  \item 再帰的探索の実行

  探索中のフォルダ内にサブフォルダが存在する場合には、
 2.i.～2.ii.の手順を再帰的に適用し、
 リスト構造として
  \texttt{FolderItems} に追加する。

  \end{enumerate}

  \item \texttt{FolderItems}の出力

  探索結果として構築した \texttt{FolderItems} をユーザ操作対応部へ出力する。
\end{enumerate}



\subsection{ファイル読込処理}\label{sec:PM_FileLoadProcess}

ファイル読込処理は、
ユーザがツリー表示上で選択した Markdown仕様ファイルを対象として、
その内容を文字列として読み込む。そして、操作ボタン領域に表示する操作ボタンの判定を行う表示パターンフラグ(\ref{sec:DrawingComponent_OperationButtons}節を参照)の切り替えを行う。
読み込んだMarkdown仕様ファイル内の文字列は、解析部、および、変換部で処理の対象となるため、\texttt{MarkdownText}としてプロジェクト管理部が保持する。

なお、ファイル読込処理を行う前までは、事前に3つの表示パターンフラグすべての値を\texttt{false}で初期化する。

本処理では、
System.IO
(\ref{sec:NET}節を参照)を用いて、
ファイル内容の読込を行う。

本処理の流れを、以下に示す。

\begin{enumerate}
  \item 呼び出しの受理

  ユーザ操作対応部、および、画面切り替え処理からの呼び出しを受け取り、ファイルの拡張子により、
  選択対象が Markdown仕様ファイルであることを確認する。

  \item 選択ファイルパスの保持

  ユーザが選択したファイルの絶対パスを、
  \texttt{SelectedFilePath} としてプロジェクト管理部が保持する。

  \item Markdown仕様ファイルの内容の読込

  \texttt{SelectedFilePath} が示す Markdown仕様ファイルを読み込み、
  その内容をMarkdown文字列として抽出する。

  \item Markdown文字列の内部状態への保持

  3.で抽出した Markdown文字列を、
  \texttt{MarkdownText} としてプロジェクト管理部が保持する。

  \item 表示パターンフラグの決定および切替

  \texttt{MarkdownText} の先頭から空行を除いた最初の行を取得し、
  その内容に基づいて表示パターンフラグを切り替える。
  
  \begin{itemize}
  \item 先頭行が、画面管理クラスを示す見出し(\texttt{\# 画面一覧})である場合
  
  表示パターンが表示パターンBであるため、\texttt{IsScreenListAddButtonVisible}を\texttt{true}にし、
  \texttt{IsClassAllButtonVisible} と\texttt{IsClassAddButtonVisible} を\texttt{false}に切り替える。
  
  \item 先頭行が、画面定義を示す見出し(\texttt{\#\#})で始まる場合
  
  表示パターンが表示パターンCであるため、\texttt{IsClassAllButtonVisible}を\texttt{true}にし、
  \texttt{IsScreenListAddButtonVisible} と\texttt{IsClassAddButtonVisible} を\texttt{false}に切り替える。
  
  \item 上記以外の場合
  
  表示パターンが表示パターンDであるため、\texttt{IsClassAddButtonVisible}を\texttt{true}にし、
  \texttt{IsScreenListAddButtonVisible} と\texttt{IsClassAllButtonVisible} を\texttt{false}に切り替える。
  \end{itemize}

  \item 解析部の呼び出し

  4.で保持した\texttt{MarkdownText}を入力として、
  解析部(\ref{sec:ParsingComponent}節を参照)を呼び出す。
  解析部は Markdown文字列を解析し、
  GUIElementのリストである\texttt{elements}を生成し、プロジェクト管理部に返す。

  \item CTM要素配置データファイルの存在確認

  選択対象 Markdown仕様ファイルと同名の
  CTM要素配置データファイル
  (拡張子 \texttt{.positions.json})が存在するかどうかを確認する。

  \item GUI要素生成部の呼び出し

      CTM要素配置データファイルが存在する場合は、
      そのファイルを読み込む。
      読み込んだCTM要素配置データと解析部から受け取った\texttt{elements}を入力として、
      GUI要素生成部(\ref{sec:GUIElementGenerationComponent}節を参照)を呼び出す。
      CTM要素配置データファイルが存在しない場合は、解析部から受け取った\texttt{elements}のみを入力として、
      GUI要素生成部(\ref{sec:GUIElementGenerationComponent}節を参照)を呼び出す。
      GUI要素生成部は、
      \texttt{elements} とCTM要素配置データファイルの情報をもとに、
      すべてのCTM要素のサイズと配置情報を\texttt{GUIElement}に設定した上で、\texttt{elements}をプロジェクト管理部に返す。


      \item \texttt{elementsの出力}

      GUI要素生成部から受け取った\texttt{elements}をユーザ操作対応部に出力する。
\end{enumerate}

\subsection{ファイル更新処理}\label{sec:FileUpdateProcess}
ファイル更新処理は、ユーザ操作対応部が保持する\texttt{elements}を受け取り、変換部へ\texttt{elements}を渡し、
変換部から受け取った
Markdown文字列、\VDM  文字列、
および CTM要素配置データを、
プロジェクトファイルへ各ファイルとして反映する処理である。
本処理では、
System.IO(\ref{sec:NET}節を参照)、
および System.Text.Json(\ref{sec:JSON}節を参照)
を用いて、
各種ファイルの保存を行う。

本処理の流れを、以下に示す。

\begin{enumerate}
  \item 入力の受け取り

  ユーザ操作対応部から\texttt{elements}を受け取り、
  本処理を実行する。

  \item Markdown 仕様の生成

  ユーザ操作対応部から受け取った\texttt{elements} を入力として、
  変換部の
  GUI 操作から Markdown 仕様への変換処理
  (\ref{sec:GUItoMarkdownConversionProcess}節を参照)を呼び出す。
  変換処理により、
  更新後の Markdown 文字列
  \texttt{updateMarkdown} を生成する。

  \item Markdown 仕様ファイルの保存

  2.で生成した \texttt{updateMarkdown} を、
  \texttt{SelectedFilePath} が示す Markdown仕様ファイルへ
  書き込み、保存する。

  保存する際、プロジェクト管理部内で保持する、
  \texttt{MarkdownText}の画面クラス名と、
  \texttt{updateMarkdown}の画面クラス名を比較し、
  クラス名が変わっている場合は\texttt{ScreenIndex}(\ref{sec:PM_ScreenTransitionProcess}節を参照)
  の画面クラス名を変更する。

  \item \VDM  仕様の生成

  2.で生成した Markdown 文字列 \texttt{updateMarkdown} を入力として、
  変換部の
  Markdown 仕様から \VDM  仕様への変換処理
  (\ref{sec:Function}節を参照)を呼び出す。
  これにより、入力の\texttt{updateMarkdown}に対応した
  \VDM の文字列である、 \texttt{VdmContent} を生成する。

  \item \VDM  ファイルの保存

  4.で生成した \texttt{VdmContent} を、
  選択中 Markdown仕様ファイルと同名の
  \VDM  ファイル(\texttt{.vdmpp})へ書き込み、保存する。
  ファイルが存在しない場合は新規作成する。
  また、\texttt{VdmContent}はユーザ操作対応部が内部で保持するため、
  ユーザ操作対応部へ出力する。

  \item CTM要素配置データの抽出

  \texttt{elements} が持つ各CTM要素について、
  要素名 \texttt{GUIElement.Name} と
  座標 (\texttt{GUIElement.X} , \texttt{GUIElement.Y}) を抽出する。

  \item CTM要素配置データファイルの保存

  6.で抽出した(要素名, 座標)の組をもとに、
  プロジェクト管理部内で保持する\texttt{SelectedFilePath} の Markdown仕様ファイルと同名の
  CTM要素配置データファイル\texttt{.positions.json} へ書き込み、保存する。
  同名のファイルが存在しない場合は、新規作成する。

  \item \texttt{MarkdownText}の更新

  プロジェクト管理部内で保持する、\texttt{MarkdownText}に、2.で生成した \texttt{updateMarkdown}を保存する。
\end{enumerate}


\subsection{画面切り替え処理}\label{sec:PM_ScreenTransitionProcess}

画面切り替え処理は、ユーザ操作対応部から画面切り替え処理の呼び出し(\ref{sec:UOM_DoubleClick}節を参照)、
および、切り替え先画面クラス名を入力として受け取り、編集対象となる画面クラスを切り替える処理である。
本処理では、編集対象となる画面クラスを切り替えることを目的として、ファイル読込処理(\ref{sec:PM_FileLoadProcess}節を参照)を呼び出し、Markdown仕様ファイルのパスを出力する。

本処理の流れを、以下に示す。

\begin{enumerate}
  \item ユーザ操作対応部から、画面要素のダブルクリック操作により、
        切り替え先画面クラス名を受け取る。

  \item プロジェクト管理部が保持している画面索引辞書(\texttt{ScreenIndex})を参照し、
        切り替え先画面クラス名\texttt{GUIElement.Name}に対応する Markdown仕様ファイルのパスを特定する。

  \item 対応する Markdown仕様ファイルが存在する場合、
        そのファイルを次の編集対象とする。

        対応する Markdown仕様ファイルが存在しない場合は、エラーをユーザ操作対応部に出力し、処理を中断する。

  \item 編集対象の切り替えに伴い、
        ファイル読込処理を呼び出し、および、対象Markdown仕様ファイルのパスを出力する。
\end{enumerate}

\subsection{新規ファイル作成処理}\label{sec:PM_FileCreate}

新規ファイル作成処理は、ユーザ操作対応部からファイル名を入力として受け取り、プロジェクトフォルダへ新規Markdown仕様ファイルを出力する処理である。
本処理では、新規Markdown仕様ファイルを作成、および、\texttt{SelectedFilePath}へ新規Markdown仕様ファイルのパスを格納し、
ファイル読込処理、および、フォルダおよびファイル探索処理を呼びだす。

本処理の流れを、以下に示す。
\begin{enumerate}
      \item ファイル名を入力として受け取る。
      \item プロジェクト管理部内で保持する、\texttt{SelectedFolderPath}のパスに「新規ファイル名.md」を加え、
      新規Markdown仕様ファイルのパスを生成する。
      \item 2.で作成したパスに、空のMarkdown仕様ファイルを作成する。
      \item フォルダおよびファイル探索処理を呼び出し、\texttt{FolderItems}を更新する。
      \item ファイル読込処理を呼び出し、\texttt{SelectedFilePath}へ新規Markdown仕様ファイルのパスを格納し、編集対象を、新規作成したMarkdown仕様ファイルにする。
\end{enumerate}


\section{解析部}\label{sec:ParsingComponent}

解析部は、Markdown仕様の記述ルール(\ref{sec:Specrule}節を参照)に従ったMarkdown仕様(リスト\ref{lst:markdown_example}を参照)の文字列を解析し、
CTM(\ref{sec:CTM}節を参照)の表示、および、操作の基礎となる\texttt{elements}を生成する処理部である。
本処理部では、表\ref{tab:ctm_elements}に示した各CTM要素を構成するデータを抽出することを目的とする。

本処理部では、.NETの標準ライブラリであるSystem.Text.RegularExpressions(\ref{sec:NET}節を参照)を用いて
Markdown文字列の各行を解析する。

本処理部の入力は、プロジェクト管理部から受けとるMarkdown文字列であり、出力はプロジェクト管理部に渡す\texttt{elements}である。

具体例として、リスト\ref{lst:markdown_example}に示すMarkdown仕様を用いる。
リスト\ref{lst:markdown_example}のMarkdown仕様に対して本処理部が生成する
GUIElement一覧を表\ref{tab:gui_element_example}に、\texttt{EventBranch}を表\ref{tab:event_branch_example}に、それぞれ示す。
本研究では、Markdown仕様の記述ルールに基づき、Markdown仕様内で「\texttt{\#\#\#}」で始まる行を見出し行と呼ぶ。

\begin{figure}[tp]
\begin{lstlisting}[caption={Markdown仕様の記述例}, label={lst:markdown_example}]
  ## 画面1
  - 80 秒でタイムアウト

  ### 有効ボタン一覧
  - ボタン1
  - ボタン2
  - ボタン3
  - ボタン4
  - ボタン5
  - ボタン6
  - 確定

  ### イベント一覧
  - タイムアウト → 画面A へ
  - ボタン1 押下 → 表示部に1 を追加
  - ボタン2 押下 → 表示部に2 を追加
  - ボタン3 押下 → 表示部に3 を追加
  - ボタン4 押下 → 表示部に4 を追加
  - ボタン5 押下 → 表示部に5 を追加
  - ボタン6 押下 → 表示部に6 を追加
  - 確定押下 →
    - 表示部に1 が入力されている → 画面K へ
    - 表示部に1 が入力されていない → 画面F へ

\end{lstlisting}
\end{figure}

\begin{table}[tp]
\centering
\caption{リスト\ref{lst:markdown_example}のMarkdown仕様記述例から生成するGUIElement一覧}
\label{tab:gui_element_example}
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Type} & \textbf{Name} & \textbf{Target} & \textbf{備考} \\
\hline
Screen & 画面1 & -- & 画面クラス \\ 
\hline
Timeout & 80 秒 & 80 秒 & タイムアウト定義 \\ 
\hline
Button & ボタン1 & 表示部に1 を追加 & 有効ボタン \\ 
\hline
Button & ボタン2 & 表示部に2 を追加 & 有効ボタン \\ 
\hline
Button & ボタン3 & 表示部に3 を追加 & 有効ボタン  \\ 
\hline
Button & ボタン4 & 表示部に4 を追加 & 有効ボタン \\ 
\hline
Button & ボタン5 & 表示部に5 を追加 & 有効ボタン \\ 
\hline
Button & ボタン6 & 表示部に6 を追加 & 有効ボタン \\ 
\hline
Button & 確定 & 確定押下 & 有効ボタン \\ 
\hline
Event & 画面Aへ & 80 秒 & タイムアウトイベント \\ 
\hline
Event & 表示部に1 を追加 & 表示部に1 を追加 & 単一イベント \\ 
\hline
Event & 表示部に2 を追加 & 表示部に2 を追加 & 単一イベント \\ 
\hline
Event & 表示部に3 を追加 & 表示部に3 を追加 & 単一イベント \\ 
\hline
Event & 表示部に4 を追加 & 表示部に4 を追加 & 単一イベント \\ 
\hline
Event & 表示部に5 を追加 & 表示部に5 を追加 & 単一イベント \\ 
\hline
Event & 表示部に6 を追加 & 表示部に6 を追加 & 単一イベント \\ 
\hline
Event & 確定押下 & -- & \begin{tabular}{l} 条件分岐を含むイベント \\\texttt{Branches}に表\ref{tab:event_branch_example}の\\\texttt{EventBranch}を保持する \\ 
\end{tabular} \\ 
\hline
\end{tabular}
\end{table}

\begin{table}[tp]
\centering
\caption{リスト\ref{lst:markdown_example}のMarkdown仕様記述例から生成するEventBranch}
\label{tab:event_branch_example}
\begin{tabular}{|l|l|}
\hline
\textbf{Condition} & \textbf{Target} \\ 
\hline
表示部に1 が入力されている & 画面K \\ 
\hline
表示部に1 が入力されていない & 画面F \\ 
\hline
\end{tabular}
\end{table}

以降、本処理部の解析処理について説明する。
\subsection{解析処理}\label{sec:ParsingProcess}

本処理は、Markdown仕様から、表\ref{tab:ctm_elements}に示したCTM要素である、画面要素、タイムアウト要素、ボタン要素、イベント要素、および分岐イベント要素を抽出し、
抽出したCTM要素を\texttt{GUIElement}として構造化し、\texttt{GUIElement}のリストである\texttt{elements}を出力する処理である。

本処理は、ユーザがプロジェクト内のMarkdown仕様を選択または更新した際に、
プロジェクト管理部のファイル読込処理(\ref{sec:PM_FileLoadProcess}節を参照)が呼び出す。
本処理はMarkdownのファイル単位で実行し、
各ファイルの内容に基づいて \texttt{elements} を生成する。
ここで、解析部が出力する \texttt{elements}の \texttt{GUIElement} は、表\ref{tb:GUIElement}のうち、以下5つののデータを保持する。
\begin{itemize}
      \item \texttt{GUIElement.Type}：CTM要素種別
      \item \texttt{GUIElement.Name}：CTM要素の名称
      \item \texttt{GUIElement.Target}：CTM要素のターゲット情報
      \item \texttt{GUIElement.Branches}：分岐イベントにおける分岐情報リスト
      \item \texttt{GUIElement.IsBranch}：\texttt{Branches}を保持しているかどうかの真偽値
\end{itemize}

本処理では、独自に定めた3つの正規表現パターンを用いてMarkdown文字列の各行を解析し、各CTM要素を抽出する。
各CTM要素の抽出に使用する独自に定めた3つの正規表現パターンを、表\ref{tab:parsing_rules}に示す。
本処理部では、正規表現パターンの1つである\texttt{BulletPattern}によって抽出した文字列を、箇条書き本文と呼ぶ。

解析処理フローを、図\ref{fig:parsing-flow}に示す。
また、本処理の流れを、以下に示す。


\begin{table}[tp]
\centering
\caption{解析部で用いる正規表現パターン}
\label{tab:parsing_rules}
\begin{tabular}{|l|p{7cm}|p{6cm}|}
\hline
\textbf{規則名} & \textbf{定義(概要)} & \textbf{用途} \\
\hline
BulletPattern
& \texttt{\detokenize{@^\s*(?:-|\*|・|・)\s+(?<Text>.+?)\s*\$}}
& ボタン名、画面要素名、イベント行、タイムアウト行の
箇条書き本文の抽出判定 \\
\hline
EventPattern
& \texttt{\detokenize{@^(?<Name>.*?)\s*→\s*(?<Target>.*)\$}}
& タイムアウト行および条件分岐行の
「→」を基準とした左右要素分解 \\
\hline
OperationPattern
& \texttt{\detokenize{@^(?<Operation>.*?)(?<Trigger>押下)\s*→\s*(?<Target>.*)\$}}
& イベント一覧における
トリガー、イベントの抽出 \\
\hline
\end{tabular}
\end{table}

\begin{figure}[tp]
  \centering
  \includegraphics[width=0.7\linewidth]{./images/kaiseki_flow.png}
  \caption{解析処理フロー}
  \label{fig:parsing-flow}

\end{figure}

\begin{enumerate}
      \item 各行の分割 

      プロジェクト管理部から入力として受け取ったMarkdown文字列を改行で分割し、
      各行を1つの要素とした配列を生成する。
      具体的には、改行で分割した各行から \texttt{\textbackslash{}r} を除去し、
      \texttt{List\textless{}string\textgreater{} lines} として保持する。
      以降の処理は、この \texttt{lines} を走査対象とする。


      \item 先頭行判定
      
      先頭行(\texttt{lines[0]})を判定材料として、
      Markdown仕様の記述ルール(\ref{sec:Specrule}節を参照)に基づき、入力のMarkdown文字列が、画面一覧仕様か画面仕様かを決定する。
      
      具体的には、
      \texttt{lines[0] == "\# 画面一覧"} を満たす場合は、
      画面一覧仕様として扱い、後述する4.A.「画面一覧仕様」の場合を行う。
      一方で、 \texttt{lines[0]} が(\texttt{"\#\# "}) で始まる場合、
      画面仕様として扱い、後述する4.B.「画面仕様」の場合を行う。
      
      リスト\ref{lst:markdown_example}の具体例では、先頭行 \texttt{lines[0]} が
      「\texttt{\#\# 画面1}」 であるため、このMarkdown仕様は画面仕様として扱う。

      \item \texttt{elements}の初期化
      
      空の\texttt{elements}を作成する。
      
      \item GUIElementの生成

      2.の先頭行判定の結果より、以下の2つの場合分けを行い、GUIElementの生成を行う。
      \begin{enumerate}[label=\Alph*.]
            \item 「画面一覧仕様」の場合
            \begin{enumerate}[label=\roman*.]
                  \item 画面一覧の抽出
                  
                  先頭行(\texttt{lines[0]})の文字列を「画面一覧」として抽出する。
                  ここでは、\texttt{GUIElement.Type} に \texttt{Screen}、
                  \texttt{GUIElement.Name} に「画面一覧」を設定したGUIElementを生成し、\texttt{elements} に追加する。

                  \item 画面抽出
                  
                  2行目(\texttt{lines[1]})以降を走査し、\texttt{BulletPattern}によって抽出した箇条書き本文を画面要素名として抽出する。

                  抽出した画面につき、 \texttt{GUIElement.Type} に \texttt{Screen}、
                  \texttt{GUIElement.Name} に画面要素名を設定したGUIElementをそれぞれ生成し、\texttt{elements} に追加する。

            \end{enumerate}

            \item 「画面仕様」の場合
            \begin{enumerate}[label=\roman*.]
                  \item 画面クラス名抽出

                  先頭行(\texttt{lines[0]})の文字列を「画面クラス名」として抽出する。
                  ここでは、\texttt{GUIElement.Type} に \texttt{Screen}、
                  \texttt{GUIElement.Name} に「画面クラス名」を設定したGUIElementを生成し、\texttt{elements} に追加する。

                  リスト\ref{lst:markdown_example}の具体例では、先頭行の「\texttt{\#\# 画面1}」から画面クラス名「\texttt{画面1}」を抽出し、
                  \texttt{GUIElement.Type}に\texttt{Screen}、\texttt{GUIElement.Name}に「\texttt{画面1}」を設定したGUIElementを生成し、\texttt{elements} に追加する。

                  \item タイムアウト抽出

                  Markdown仕様の記述ルール(\ref{sec:Specrule}節を参照)に基づき、タイムアウト時間は2行目に記述するため、
                  2行目(\texttt{lines[1]})をタイムアウト記述フィールドとして扱い、
                  \texttt{BulletPattern}によって抽出した箇条書き本文からタイムアウトに関する情報を抽出する。
                  2行目が箇条書き行でない場合、タイムアウト記述フィールドが存在しないものとしてスキップする。

                  ここでは、箇条書き本文中から文字「\texttt{で}」 を探索し、
                  「\texttt{で}」の前の文字列をタイムアウト名として抽出する。
                        抽出したタイムアウト名をもとに、
                  \texttt{GUIElement.Type}に \texttt{Timeout}、\texttt{GUIElement.Name}、および、\texttt{GUIElement.Target}にタイムアウト名を設定したGUIElementを生成し、\texttt{elements} に追加する。
                  
                  リスト\ref{lst:markdown_example}の具体例では、2行目の「\texttt{- 80 秒でタイムアウト}」をタイムアウト記述フィールドとして解析する。
                  箇条書き本文から「\texttt{で}」より前の文字列(\texttt{80 秒})を抽出する。
                  抽出したタイムアウト名をもとに、
                  CTM要素種別として\texttt{GUIElement.Type}に\texttt{Timeout}、CTM要素の名称として\texttt{GUIElement.Name}に 80 秒、CTM要素の遷移先として\texttt{GUIElement.Target}に 80 秒を設定したGUIElementを生成し、 \texttt{elements} に追加する。

                  \item ボタン抽出

                  \begin{enumerate}[label=\alph*.]
                        \item 有効ボタン記述フィールドを表す見出し行を探索

                       4.B.ii.の次行以降を走査し、行頭が「\texttt{\#}」から始まるかどうかを確認する。
                        「\texttt{\#}」を見つけた場合、該当行の「\texttt{\#}」を取り除いた文字列を見出し名として抽出する。
                        抽出した見出し名が「有効ボタン一覧」と一致した場合、該当行の次行を有効ボタン記述フィールドの開始行として扱う。

                        リスト\ref{lst:markdown_example}の具体例では、タイムアウト記述フィールドの次行である3行目\texttt{lines[2]}から走査を開始し、4行目\texttt{lines[3]}の見出し行「\texttt{\#\#\# 有効ボタン一覧}」を発見する。

                        \item 有効ボタン記述フィールドの範囲を決定
                        
                        有効ボタン記述フィールドの開始行から\texttt{lines}を走査し、有効ボタン記述フィールドの終了行を探索する。
                        終了行の判定は、以下のいずれかを満たす行に到達した場合とする。
                        \begin{itemize}
                              \item 見出し行(「\texttt{\#\#\#}」で始まる行)に到達する。
                              \item ファイル末尾に到達する。
                        \end{itemize}

                        リスト\ref{lst:markdown_example}の具体例では、有効ボタン記述フィールドの終了行は13行目\texttt{lines[12]}の見出し行「\texttt{\#\#\# イベント一覧}」であるため、
                        12行目\texttt{lines[11]}までを有効ボタン記述フィールドとする。

                        \item ボタン要素を抽出

                        有効ボタン記述フィールド内の各行について、正規表現パターンの1つである\texttt{BulletPattern} により箇条書きかどうかを判定し、
                        \texttt{BulletPattern}によって抽出した箇条書き本文をボタン名として抽出する。
                        箇条書きでない行はボタン要素として扱わず、スキップする。
                        
                        リスト\ref{lst:markdown_example}の具体例では、5行目\texttt{lines[4]}から12行目\texttt{lines[11]}までの各行を走査し、
                        抽出した各箇条書き本文を、それぞれボタン名として抽出する。5行目の「\texttt{ボタン1}」から、
                        11行目の「\texttt{確定}」までをそれぞれ抽出し、12行目は空行であるためスキップする。

                        \item ボタン要素をGUIElementとして生成

                        抽出したボタン名について、\texttt{HashSet\textless{}string\textgreater{}}(\ref{sec:NET}節を参照)を用いて重複判定を行う。
                        重複していない場合、\texttt{GUIElement.Type}に \texttt{Button}、
                        \texttt{GUIElement.Name}に3.B.iii.c.で抽出したボタン名を設定した\texttt{GUIElement}を生成し、\texttt{elements} に追加する。
                        重複していた場合、該当行のボタン要素の生成をスキップする。
                        
                        リスト\ref{lst:markdown_example}の具体例では、抽出した各ボタン名について重複判定を行い、
                        全て重複していないため、各ボタン名をもとに
                        \texttt{GUIElement.Type}に\texttt{Button}、\texttt{GUIElement.Name}に
                        \texttt{ボタン1}から\texttt{確定}をそれぞれ設定した\texttt{GUIElement}を生成し、\texttt{elements} に追加する。
                  \end{enumerate}

                  \item イベント抽出
                  \begin{enumerate}[label=\alph*.]
                        \item イベント記述フィールドを表す見出し行を探索

                        4.B.iii.a.と同様に見出し行を探索し、
                        抽出した見出し名が「イベント一覧」と一致した場合、
                        該当行の次行をイベント記述フィールドの開始行として扱う。

                        リスト\ref{lst:markdown_example}の具体例では、タイムアウト記述フィールドの次行である3行目\texttt{lines[2]}から走査を開始し、
                        13行目\texttt{lines[12]}の見出し行「\texttt{\#\#\# イベント一覧}」を発見する。

                        \item イベント記述フィールドの範囲を決定

                        イベント記述フィールドの開始行から\texttt{lines}を走査し、イベント記述フィールドの終了行を探索する。
                        終了行の判定は、以下のいずれかを満たす行に到達した場合とする。
                        \begin{itemize}
                              \item 見出し行(「\texttt{\#\#\#}」で始まる行)に到達する。
                              \item ファイル末尾に到達する。
                        \end{itemize}

                        リスト\ref{lst:markdown_example}の具体例では、イベント記述フィールドの終了行はファイル末尾であるため、最後の行である23行目\texttt{lines[22]}までをイベント記述フィールドとする。

                        \item イベント文字列を抽出

                        イベント記述フィールド内の各行について、
                        \texttt{BulletPattern} により箇条書き行かどうかを判定し、
                        各箇条書き本文を、イベント文字列として抽出する。
                        箇条書き行でない場合はイベント定義ではないためスキップする。

                        リスト\ref{lst:markdown_example}の具体例では、14行目\texttt{lines[13]}から23行目\texttt{lines[22]}までの各行を走査し、
                        箇条書き本文をそれぞれイベント文字列として抽出する。
                        14行目の「\texttt{タイムアウト → 画面A へ}」から、
                        23行目の「\texttt{表示部に1 が入力されていない → 画面F へ}」までをそれぞれ抽出する。


                        \item イベント文字列の書式を判定

                        4.B.iv.cで抽出したイベント文字列に対し、
                        まず、正規表現パターンの1つである\texttt{OperationPattern} を適用し、
                        「\texttt{\detokenize{@^(?<Operation>.*?)(?<Trigger>押下)\s*→\s*(?<Target>.*)\$}}」に該当するかを判定する。
                        該当する場合は、
                        (\texttt{押下 →})の直前までの文字列を対象ボタン名\texttt{buttonkey}、
                        (\texttt{→})以降の文字列をイベント内容\texttt{eventContent}としてそれぞれ抽出する。

                        ここで、\texttt{OperationPattern}に該当するが、
                        抽出したイベント内容\texttt{eventContent}が空である場合は、
                        当該イベントは分岐イベントとして扱う。
                        分岐イベントを検出した際は、直後の行から順に走査し、条件分岐行を抽出し、\texttt{elements}へ分岐イベントとして追加する。
                        抽出した条件分岐行に対する詳細な処理規則および生成するデータ構造については、
                        \ref{sec:ParsingBranch}節で詳しく説明する。

                        また、\texttt{OperationPattern}に該当しない場合は、正規表現パターンの1つである\texttt{EventPattern} を適用し、
                        「左辺 \texttt{→} 右辺」の形式として扱い、
                        (\texttt{→})を区切り文字として、左側文字列\texttt{leftText}と、右側文字列\texttt{rightText}を抽出する。

                        リスト\ref{lst:markdown_example}の具体例では、14行目の「\texttt{タイムアウト\allowbreak  → \allowbreak 画面A へ}」が\texttt{OperationPattern}に該当せず
                        「\texttt{EventPattern}」に該当するため、
                        左側文字列\texttt{leftText}として「\texttt{タイムアウト}」を、
                        右側文字列\texttt{rightText}として「\texttt{画面A へ}」を抽出する。
                        15行目の「\texttt{ボタン1 押下\allowbreak  →  \allowbreak 表示部に1 を追加}」が
                        \texttt{OperationPattern}に該当するため、
                        対象ボタン名\texttt{buttonkey}として「\texttt{ボタン1}」を、
                        イベント内容\texttt{eventContent}として「\texttt{表示部に1 を追加}」を抽出する。

                        \item イベント文字列とボタン要素の対応付け

                        \texttt{OperationPattern}に該当するイベント文字列について、
                        抽出した対象ボタン名\texttt{buttonkey}をキーとして、
                        \texttt{elements}から既に生成済みのボタン要素を探索する。
                        探索時には、
                        \texttt{elements}中のボタン要素(\texttt{GUIElement.Type\allowbreak  == \allowbreak Button})のそれぞれの名称(\texttt{GUIElement.\allowbreak Name})と\texttt{buttonkey}で比較を行い、
                        対象のイベント文字列に対応するボタン要素を特定する。
                        対応するボタン要素が存在する場合、
                        対応するボタン要素のTarget属性\texttt{GUIElement.Target}に
                        イベント内容\texttt{eventContent}を設定する。
                        対応するボタン要素が存在しない場合、
                        当該イベントは対応ボタンの無いイベントとして扱い、スキップする。
                        
                        リスト\ref{lst:markdown_example}の具体例では、15行目の「\texttt{ボタン1 押下 → 表示部に1 を追加}」に対し、
                        抽出した対象ボタン名\texttt{buttonkey}である「\texttt{ボタン1}」をキーとして
                        \texttt{elements}から対応するボタン要素を探索し、特定する。
                        対応するボタン要素「\texttt{ボタン1}」は\texttt{elements}に存在するため、
                        ボタン要素「\texttt{ボタン1}」のTarget属性\texttt{GUIElement.Target}にイベント内容\texttt{eventContent}である「\texttt{表示部に1 を追加}」を設定する。
                        21行目の「\texttt{確定 押下 → }」に対しては、
                        抽出した対象ボタン名\texttt{buttonkey}である「\texttt{確定}」をキーとして
                        \texttt{elements}から対応するボタン要素を探索し、特定する。
                        対応するボタン要素「\texttt{確定}」は\texttt{elements}に存在するが、
                        イベント内容\texttt{eventContent}が空であるため、
                        当該イベントは分岐イベントとして扱い、ボタン要素との対応付けをスキップする。

                        \item 単一イベント要素を生成

                        分岐イベントに該当しない場合、
                        解析部は単一イベントとして\texttt{GUIElement}の生成を行う。
                        \texttt{OperationPattern}形式のイベントでは、
                        \texttt{GUIElement.Type == Event} の\texttt{GUIElement}を生成する。
                        このとき、
                        \texttt{eventContent}を \texttt{GUIElement.Name} 、および、
                        \texttt{GUIElement.Target}それぞれに設定し、
                        \texttt{elements} に追加する。
                        
                        一方で、
                        \texttt{EventPattern}形式のイベントでは、
                        \texttt{GUIElement.Type} に\texttt{Event}、
                        \texttt{GUIElement.Name} に\texttt{leftText}、
                        \texttt{GUIElement.Target}に\texttt{rightText}、
                        を設定した\texttt{GUIElement}を生成する。
                        また、左辺文字列(\texttt{leftText})が「\texttt{leftText == タイムアウト}」である場合、
                        既に生成済みのタイムアウト要素(\texttt{GUIElement.Type == Timeout})を
                        \texttt{elements} から探索する。
                        タイムアウト要素が存在する場合、
                        \texttt{GUIElement.Type}に \texttt{Event} 、\texttt{GUIElement.Name}に\texttt{rightText}、
                        \texttt{GUIElement.Target} に該当するタイムアウト要素の\texttt{GUIElement.Name}を設定した\texttt{GUIElement}を生成する。

                        リスト\ref{lst:markdown_example}の具体例では、14行目の「\texttt{タイムアウト → 画面A へ}」に対し、
                        抽出した左側文字列(\texttt{leftText})が「\texttt{タイムアウト}」であるため、
                        既に生成済みのタイムアウト要素を探索する。
                        \texttt{elements}中にタイムアウト要素「\texttt{80 秒}」が存在するため、
                        \texttt{GUIElement.Type} に\texttt{Event}、\texttt{GUIElement.Name}に「\texttt{画面Aへ}」、
                        \texttt{GUIElement.Target}に\texttt{80 秒}を設定したGUIElementを生成し、 \texttt{elements} に追加する。
                        
                        また、15行目の「\texttt{ボタン1 押下 → 表示部に1 を追加}」に対し、
                        \texttt{GUIElement.Type} に\texttt{Event}、\texttt{GUIElement.Name}に\texttt{表示部に1 を追加}、
                        \texttt{GUIElement.Target}に\texttt{表示部に1 を追加}を設定した\texttt{GUIElement}を生成し、 \texttt{elements} に追加する。


                  \end{enumerate}

            \end{enumerate}
      \end{enumerate}
      \item \texttt{elements}を出力

      全CTM要素に対する\texttt{GUIElement}を生成した後、
      解析処理は\texttt{elements}をプロジェクト管理部へ返す。
\end{enumerate}

\subsection{条件分岐の解析処理}\label{sec:ParsingBranch}

本節では、イベント一覧セクション内に記述している分岐イベントについて、
分岐条件および分岐先イベントを抽出し、
\texttt{GUIElement} の \texttt{Branches}(表\ref{tb:EventBranch}を参照)へ格納する処理を説明する。
分岐イベントは、単一のトリガ(ボタン押下等)に対して複数の分岐条件と分岐先イベントを列挙する記述であり、
通常の単一イベントとは異なる解析規則を適用する必要があるため、
独立した処理として扱う。

\subsubsection{対象とする記述}

解析部は、分岐イベントを以下の形式で判定する。
親イベント行とは、分岐イベントのトリガを表す行である。
分岐行とは、親イベント行に対応する各分岐条件および分岐先イベントを表す行である。

\begin{itemize}
      \item 親イベント行：\texttt{- \{Operation\}\{押下\} → 空文字列}(例：\texttt{- 確定 押下 → })
      \item 分岐行：\texttt{- \{Condition\} → \{Target\}}(例：\texttt{  - 表示部に1が入力されている → 画面Kへ})
\end{itemize}

親イベント行は、表\ref{tab:parsing_rules}に示す正規表現パターン \texttt{OperationPattern}
により検出し、
分岐行は、表\ref{tab:parsing_rules}に示す正規表現パターン\texttt{EventPattern}
により「\texttt{→}」を区切り文字として左右へ分解する。

\subsubsection{分岐イベント解析処理の処理の流れ}\label{sec:ParsingBranchFlow}

本処理は、イベント記述フィールドの走査中に検出した
「親イベント行(\texttt{OperationPattern}に一致し、かつ「\texttt{→}」の右辺が空文字列)」を起点として、
後続の分岐行を収集し、\texttt{Branches}を保持する親イベント要素を生成する処理である。

本処理の流れを、以下に示す。

\begin{enumerate}
      \item 親イベント行候補の判定

      イベント記述フィールド内で抽出したイベント文字列に対し、
      \texttt{OperationPattern} を適用し、
      操作名 \texttt{buttonkey} と「\texttt{→}」以降の文字列 \texttt{eventContent} を抽出する。
      ここで \texttt{eventContent} が空である場合、
      当該行を分岐イベントの親イベント行として扱い、
      本処理を実行する。
      \texttt{eventContent} が空でない場合は条件分岐として扱わず、
      本処理は実行しない。

      リスト\ref{lst:markdown_example}の具体例では、21行目の「\texttt{確定押下 → }」は \texttt{OperationPattern} に一致し、
      \texttt{buttonkey}として\texttt{確定}、\texttt{eventContent}として\texttt{""} を得るため、
      分岐イベントとして扱い、この行を親イベント行とする。

      \item 親イベントに対応するボタン要素の特定

      親イベント行から抽出した\texttt{buttonkey} をキーとして、
      既に生成済みのボタン要素(\texttt{GUIElement.Type\allowbreak  == \allowbreak Button})を \texttt{elements} から探索する。
      対応するボタン要素が存在する場合、
      以降の親イベント要素生成時に参照するため、
      \texttt{correspondingButton} として保持する。

      リスト\ref{lst:markdown_example}の具体例では、\texttt{buttonkey == 確定} をキーとして
      有効ボタン一覧で生成済みのボタン要素「\texttt{確定}」を探索し、
      \texttt{correspondingButton}として\texttt{確定}を保持する。

      \item \texttt{branches}の初期化

      親イベント行の直後の行番号を開始位置として設定する。
      併せて、分岐情報を保持する \texttt{List\textless{}EventBranch\textgreater{} branches} を空のリストとして生成する。

      リスト\ref{lst:markdown_example}の具体例では、「\texttt{確定 押下 → }」の直後の行を分岐行収集の開始位置とし、
      \texttt{branches} を空のリストとして生成する。

      \item 分岐行の収集範囲の走査

      順に各行を走査し、
      各行が分岐行候補かどうかを判定しながら分岐行候補を収集する。
      分岐行として扱う候補行は、箇条書き本文を抽出できる行である。
      具体的には、\texttt{BulletPattern}により
      箇条書き本文 \texttt{nestedContent} を抽出できた場合に限り、
      当該行を分岐行候補として扱う。

      リスト\ref{lst:markdown_example}の具体例では、親イベント行の直後の
      「\texttt{  - 表示部に1が入力されている \allowbreak → \allowbreak 画面Kへ}」および
      「\texttt{  - 表示部に1が入力されていない → 画面Fへ}」
      の2行が箇条書き本文として抽出可能であるため、分岐候補として扱う。

      \item 終了条件の判定

      分岐行の誤取り込みを防ぐため、
      走査中に以下のいずれかを満たした場合、
      分岐行候補の収集を終了する。

      \begin{itemize}
            \item 空行に到達した場合。
            \item 見出し行(\texttt{\#\#\#}で始まる行)に到達した場合。
            \item 箇条書き本文抽出に失敗した場合。
            \item 箇条書き本文 \texttt{nestedContent} が
                  \texttt{OperationPattern} に一致する場合、
                  または \texttt{nestedContent} が「タイムアウト」で始まる場合。
            \item ファイル末尾に到達した場合。
      \end{itemize}

      リスト\ref{lst:markdown_example}の具体例では、23行目の分岐行の次にファイル末尾が現れた時点で、
      分岐行候補の収集を終了する。

      \item 分岐行の本文抽出と左右要素の分解

      分岐行候補として、箇条書き本文 \texttt{nestedContent} を取得した後、
      \texttt{EventPattern} を適用し、
      「\texttt{→}」 を区切り文字として左側文字列 \texttt{leftText} と右側文字列 \texttt{rightText} を抽出する。
      分岐行候補が\texttt{EventPattern} に一致した場合は、
      \texttt{leftText} を分岐条件(\texttt{Condition})、
      \texttt{rightText} を分岐先イベント(\texttt{Target})として扱う。
      一致しない場合は、
      当該本文を条件のみの記述として扱い、
      \texttt{Condition}に\texttt{nestedContent}を設定し、
      \texttt{Target} は空として扱う。

      リスト\ref{lst:markdown_example}の具体例では、
      「\texttt{表示部に1が入力されている → 画面Kへ}」を
      \texttt{Condition == 表示部に1が入力されている}、
      \texttt{Target == 画面Kへ} に分解する。

      \item \texttt{EventBranch}の生成と\texttt{branches}への追加

      6.で得た(\texttt{Condition}, \texttt{Target})をもとに
      \texttt{EventBranch} を生成し、3.で生成した\texttt{branches} に追加する。
      \texttt{branches}への追加は分岐行の出現順に行い、
      仕様記述における分岐の順序を保持する。

      リスト\ref{lst:markdown_example}の具体例では、2つの分岐について
      \texttt{(表示部に1が入力されている、画面Kへ)}、
      \texttt{(表示部に1が入力されていない、画面Fへ)}
      の順に \texttt{EventBranch}を生成し、\texttt{branches} へ追加する。

      \item 親イベント要素の生成

      \texttt{branches} を1件以上収集できた場合、
      親イベント要素(\texttt{GUIElement.Type == Event})を生成し、
      \texttt{GUIElement.Branches }に\texttt{ branches} を設定して \texttt{elements} に追加する。
      親イベント要素の \texttt{GUIElement.Name} は操作トリガを表すために
      \texttt{\texttt{correspondingButton}押下} の形式とする。
      さらに、
      そのボタン要素(\texttt{GUIElement.Type == Button})のTarget属性に「\texttt{\texttt{correspondingButton}押下}」を設定する。

      リスト\ref{lst:markdown_example}の具体例では、
      親イベント要素として、
      \texttt{GUIElement.Type}に\texttt{Event}、
      \texttt{GUIElement.Name}に「\texttt{確定押下}」、
      \texttt{GUIElement.Target}に\texttt{空文字列}を、
      \texttt{GUIElement}にそれぞれ
      設定する。

      また、対応するボタン要素「\texttt{確定}」を表す\texttt{GUIElement}のTarget属性\texttt{GUIElement.Target}に
      「\texttt{確定押下}」を設定する。

      \item 不完全な分岐記述の扱い

      分岐行を1件も収集できなかった場合は、
      条件分岐として成立しない記述であるため、
      親イベント要素を生成せず、
      当該親イベント行はスキップする。

\end{enumerate}


\section{GUI要素生成部}\label{sec:GUIElementGenerationComponent}

GUI要素生成部は、解析部(\ref{sec:ParsingComponent}節を参照)で生成した
\texttt{elements} をプロジェクト管理部(\ref{sec:ProjectManagementComponent}節を参照)から入力として受け取る。
同時に、対象とするMarkdown仕様に対応するCTM要素配置データをプロジェクト管理部から受け取る。
GUI要素生成部は、受け取った\texttt{elements}とCTM要素配置データを統合し、
CTM上で表示および操作可能なCTM要素を生成する処理部である。

CTM要素生成部が出力する\texttt{GUIElement}は、CTM領域上の表示、および、操作に必要な以下の情報を保持する。
\begin{itemize}
  \item \texttt{X}：CTM要素のX座標
  \item \texttt{Y}：CTM要素のY座標
  \item \texttt{Width}：CTM要素の幅
  \item \texttt{Height}：CTM要素の高さ
  \item \texttt{IsMovable}：CTM要素の移動可能状態
  \item \texttt{IsSelected}：CTM要素の選択状態
\end{itemize}

GUI要素生成部の入力は、プロジェクト管理部から受け取る \texttt{elements} と、
必要に応じてプロジェクト管理部から受け取るCTM要素配置データである。
出力は、座標および表示サイズが確定した\texttt{elements} であり、
これをプロジェクト管理部へ返却する。

\subsubsection{初期配置規則}\label{subsec:initial_layout_rule}

CTM要素配置データが存在し、かつ \texttt{GUIElement.Name} をキーとして座標が取得できる場合は、
当該座標を優先して\texttt{GUIElement}の\texttt{X,Y} に設定する。
一方、CTM要素配置情報が存在しない場合、
GUI要素生成部がCTM要素種別に応じた初期配置規則に基づいて座標を決定する。

初期配置では、CTM要素種別ごとに縦方向へ配置する。
このとき、CTM要素種別ごとの 0 始まりの連番を
$i_{\mathrm{screen}}, i_{\mathrm{button}}, i_{\mathrm{event}}$
とし、同一CTM要素種別内の出現順に増加させる。

初期配置に用いる定数を、以下に定義する。
左列の基準X座標を $X_{\mathrm{left}}=40\mathrm{Px}$、
ノード幅を $W_{\mathrm{node}}=160\mathrm{Px}$、
ノード高さを $H_{\mathrm{node}}=45\mathrm{Px}$、
列間隔を $S_{\mathrm{col}}=40\mathrm{Px}$、
縦方向間隔を $d=80\mathrm{Px}$ とする。

イベント要素のX座標 $X_{\mathrm{mid}}$を、式\ref{eq:column_x_positions_single_timeout}で定義する。
\begin{equation}\label{eq:column_x_positions_single_timeout}
X_{\mathrm{mid}} = X_{\mathrm{left}} + W_{\mathrm{node}} + S_{\mathrm{col}}
\end{equation}

各CTM要素の初期配置規則を、以下に示す。
\begin{itemize}
\item \textbf{タイムアウト要素}

本研究では、タイムアウト要素は単一要素として取り扱う。
したがって、タイムアウトは固定位置に配置する。

タイムアウト要素が存在し、かつ、CTM要素配置データに存在している場合は、
当該座標を設定する。
タイムアウト要素が存在し、かつ、CTM要素配置データに存在しない場合は、CTM領域左上の固定位置に配置する。
固定位置の設定を、式\ref{eq:timeout_position_single}に示す。ここで、タイムアウト要素の基準座標を($X(time)$ , $Y(time)$)とする。
\begin{equation}\label{eq:timeout_position_single}
X(time)=X_{\mathrm{left}},\quad
Y(time)=8\mathrm{px}
\end{equation}

\item \textbf{画面要素}

未配置の画面要素 $s_{i_{\mathrm{screen}}}$ の座標は、式\ref{eq:screen_position_single_timeout}で計算する。
\begin{equation}\label{eq:screen_position_single_timeout}
X(s_{i_{\mathrm{screen}}})=X_{\mathrm{left}},\quad
Y(s_{i_{\mathrm{screen}}})=i_{\mathrm{screen}}\cdot d
\end{equation}



\item \textbf{ボタン要素}

ボタン要素の配置開始位置を $Y_{\mathrm{base}}$ とする。
タイムアウト要素が存在する場合は、その下端に余白を加えた位置を用い、
存在しない場合は上端余白から配置を開始する。ボタン要素の配置開始位置は、式\ref{eq:y_base_single_timeout}で計算する。
\begin{equation}\label{eq:y_base_single_timeout}
Y_{\mathrm{base}}=
\begin{cases}
Y(time)+H_{\mathrm{node}}+10\mathrm{px} & (\text{タイムアウト要素が存在する})\\
40\mathrm{px} & (\text{タイムアウト要素が存在しない})
\end{cases}
\end{equation}


未配置のボタン要素 $b_{i_{\mathrm{button}}}$の座標は、式\ref{eq:button_position_single_timeout}で計算する。
\begin{equation}\label{eq:button_position_single_timeout}
X(b_{i_{\mathrm{button}}})=X_{\mathrm{left}},\quad
Y(b_{i_{\mathrm{button}}})=Y_{\mathrm{base}} + i_{\mathrm{button}}\cdot d
\end{equation}

\item \textbf{イベント要素}

タイムアウト要素の秒数が存在し、かつ、当該イベントがタイムアウトに対応する場合は、
イベントをタイムアウトと同じY座標に配置する。タイムアウトに対応する
未配置のイベント要素 $e_{i_{\mathrm{event}}}$の座標は、式\ref{eq:event_timeout_position_single_timeout}で決定する。
\begin{equation}\label{eq:event_timeout_position_single_timeout}
X(e_{i_{\mathrm{event}}})=X(time)+\left(W_{\mathrm{node}}+120\mathrm{px}\right),\quad
Y(e_{i_{\mathrm{event}}})=Y(time)
\end{equation}

タイムアウトに対応しないイベント要素は、対応するボタン要素を探索し、
見つかった場合は当該ボタンと同じY座標に配置する。
対応ボタンはボタン要素の\texttt{GUIElement.Target}と、イベント要素の\texttt{GUIElement.Name}を比較し、一致したときに対応ボタンとして確定する。
対応ボタンが存在する未配置のイベント要素 $e_{i_{\mathrm{event}}}$の座標は、対応するボタン要素のY座標を$Y(button)$として、式\ref{eq:event_button_position_single_timeout}で決定する。
\begin{equation}\label{eq:event_button_position_single_timeout}
X(e_{i_{\mathrm{event}}})=X_{\mathrm{mid}},\quad
Y(e_{i_{\mathrm{event}}})=Y(button)
\end{equation}

上記のいずれにも該当しないイベント要素は、
イベント出現順の連番 $i_{\mathrm{event}}$ に基づいて縦方向へ下向きに配置する。
上記のいずれにも該当しない未配置のイベント要素 $e_{i_{\mathrm{event}}}$の座標は、式\ref{eq:event_fallback_position_single_timeout}で決定する。
\begin{equation}\label{eq:event_fallback_position_single_timeout}
X(e_{i_{\mathrm{event}}})=X_{\mathrm{mid}},\quad
Y(e_{i_{\mathrm{event}}})=Y_{\mathrm{base}} + i_{\mathrm{event}}\cdot d
\end{equation}
\end{itemize}

本処理の流れを、以下に示す。

\begin{enumerate}
      \item 入力の受け取り

      プロジェクト管理部から \texttt{elements} を入力として受け取る。
      併せて、種別ごとの配置インデックス $i$ を 0 で初期化する。

      \item \texttt{elements} の走査と要素種別の判定

      \texttt{elements} を2行目から順に走査し、
      各要素について \texttt{GUIElement.Type} を参照してCTM要素種別を判定する。

      \begin{itemize}
      \item 画面要素の生成

      \texttt{GUIElement.Type} が \texttt{Screen} の場合、
      以下の手順で画面要素に対応するCTM要素を生成する。
      \begin{enumerate}[label=\roman*.]
            \item 画面要素に対応するインデックス $i$ を取得する。
            \item 表\ref{tab:gui_node_spec}に基づき、画面要素の既定サイズを\texttt{GUIElement.Width}、および、\texttt{GUIElement.Height}に設定する。
            \item 座標を決定する。
                  CTM要素配置データに一致する座標が存在する場合はそれを設定し、
                  存在しない場合は前述の初期配置規則により初期配置座標を算出して設定する。
            \item 画面要素はユーザ操作により移動可能とし、
                  \texttt{GUIElement.IsMovable} に\texttt{true} を設定する。
            \item 生成したCTM要素を\texttt{elements}へ追加し、
                  画面要素に対応するインデックス $i$ を1増やす。
      \end{enumerate}

      \item タイムアウト要素の生成

      \texttt{GUIElement.Type} が \texttt{Timeout} の場合、
      以下の手順でタイムアウト要素に対応するCTM要素を生成する。
      \begin{enumerate}[label=\roman*.]
            \item 表\ref{tab:gui_node_spec}に基づき、既定サイズ\texttt{GUIElement.Width}、および、\texttt{GUIElement.Height}に設定する。
            \item 座標を決定する。
            CTM要素配置データに一致する座標が存在する場合はそれを設定し、
            存在しない場合は前述の初期配置規則により初期配置座標を算出して設定する。
            \item タイムアウト要素は画面構造の基準として扱うため移動不可とし、
            \texttt{GUIElement.IsMovable} に\texttt{false}を設定する。
            \item 生成したCTM要素を\texttt{elements}へ追加する。
      \end{enumerate}

      \item ボタン要素の生成

      \texttt{GUIElement.Type} が \texttt{Button} の場合、
      以下の手順でボタン要素に対応するCTM要素を生成する。
      \begin{enumerate}[label=\roman*.]
            \item ボタン要素に対応するインデックス $i$ を取得する。
            \item 表\ref{tab:gui_node_spec}に基づき、既定サイズ\texttt{GUIElement.Width}、および、\texttt{GUIElement.Height}に設定する。
            \item 座標を決定する。
            CTM要素配置データに一致する座標が存在する場合はそれを設定し、
            存在しない場合は前述の初期配置規則により初期配置座標を算出して設定する。
            \item ボタン要素はユーザ操作により移動可能とし、
            \texttt{GUIElement.IsMovable} に\texttt{true} を設定する。
            \item 生成したCTM要素を\texttt{elements}へ追加し、
            ボタン要素に対応するインデックス $i$ を1増やす。
      \end{enumerate}



      \item イベント要素の生成

      \texttt{GUIElement.Type} が \texttt{Event} の場合、
      以下の手順でイベント要素、または、分岐イベント要素に対応するCTM要素を生成する。
      \begin{enumerate}[label=\roman*.]
            \item 当該イベント要素が条件分岐を含むかどうかを判定する。
            具体的には \texttt{GUIElement.Branches} に\texttt{EventBranch}が1つ以上存在する場合は、分岐イベントとする。
            \item 条件分岐を含まない場合は、
            表\ref{tab:gui_node_spec}に基づき、既定サイズ\texttt{GUIElement.Width}、および、\texttt{GUIElement.Height}に設定する。
            座標はCTM要素配置データを優先し、
            CTM要素配置データが存在しない場合は前述の初期配置規則により初期配置座標を算出して設定する。
            \item 条件分岐を含む場合は、
            親イベント要素を表示対象外として扱い、
            分岐イベント要素における分岐条件、および、分岐先イベントの
            具体的な描画位置、
            および、分岐線の描画に関する計算は、
            GUI要素生成部では行わない。
            これらの計算は、描画部(\ref{sec:DrawingComponent}節を参照)において、
            基準となるイベント要素および分岐順序に基づいて動的に決定する。
      \end{enumerate}

      \end{itemize}
      \item 出力

      全CTM要素の生成が完了した後、
      生成した\texttt{elements}をプロジェクト管理部へ出力する。
\end{enumerate}



\section{変換部}\label{sec:ConversionComponent}
変換部は、ユーザによるCTMの編集内容をMarkdown仕様、および、VDM++仕様へ変換する処理部である。
本処理部では、Markdown仕様からVDM++仕様の変換に加え、ユーザによるGUI操作結果をMarkdown仕様へ反映する処理を行う。
Markdown仕様からVDM++仕様への変換処理については、既存の\tool の変換ルールAおよび変換ルールBに基づく\VDM 仕様への変換機能(\ref{sec:Function}節を参照)を利用する。

以降、本節では、本研究で追加したGUI操作からMarkdown仕様への変換処理、
および、出力順序整理処理について説明する。

\subsection{GUI操作からMarkdown仕様への変換処理}\label{sec:GUItoMarkdownConversionProcess}
本処理は、ユーザ操作対応部が所持する\texttt{elements}、お
よび、プロジェクト管理部より受け取る更新前のMarkdown文字列を入力として、
更新後Markdown文字列へ変換する処理である。
まず、\texttt{elements}内の各CTM要素を、種類および関連関係に基づいて分類する。
次に、各CTM要素を
Markdown仕様として出力する順序を決定する。

Markdown仕様への変換処理は、Markdown仕様の記述ルール(\ref{sec:Specrule}節を参照)に準拠しており、
以下の要素を順に変換する。
\begin{itemize}
      \item 画面
      \item タイムアウト
      \item 有効ボタン一覧
      \item イベント一覧
\end{itemize}

変換処理の結果として生成する更新後Markdown文字列は、
プロジェクト管理部に引き渡し、
ファイル更新処理(\ref{sec:FileUpdateProcess}節を参照)により保存する。
これにより、
常にCTM上の編集操作と仕様記述との
対応関係を保つことが可能である。

本処理の流れを、以下に示す。
\begin{enumerate}
      \item 入力として、\texttt{elements} および更新前のMarkdown文字列を受け取る。

      \item 取得した\texttt{elements}、および、更新前のMarkdown文字列を、
        出力順序決定のために出力順序整理処理に入力する(\ref{sec:ConversionOrderProcess}節を参照)。出力順序整理処理は、Markdown文字列各行を1つの要素とした配列である
      \texttt{lines} を出力する。
        
      \item 出力順序整理処理が出力した\texttt{lines} が格納するMarkdown文字列各行を連結し、
        最終的なMarkdown文字列
        \texttt{updateMarkdown} を生成する。
      \item 生成した \texttt{Markdown} を更新後Markdown文字列として
        プロジェクト管理部に渡す。

\end{enumerate}


\subsection{出力順序整理処理}\label{sec:ConversionOrderProcess}
本処理では、\texttt{elements} およびMarkdown文字列を入力として、
Markdown文字列のうち「画面一覧フィールド」、「有効ボタン記述フィールド」、および、「イベント記述フィールド」の並び順を
CTM上の配置順序に一致するよう再構成する。
本処理は、CTM上の配置順序とMarkdown仕様を一致させることを目的とする。

本処理の流れを、以下に示す。
\begin{enumerate}
      \item GUI操作からMarkdown仕様への変換処理(\ref{sec:GUItoMarkdownConversionProcess}節を参照)
      から、入力としてMarkdown文字列と
      \texttt{elements}を受け取る。
      \item Markdown文字列を読み込み、Markdown文字列各行を1つの要素とした配列(\texttt{lines})として保持する。
      
      \item 各CTM要素を順に処理する。
      
       以降、各CTM要素を順に処理する。
      \begin{enumerate}[label=\roman*.]
            \item 画面要素の生成
            \begin{enumerate}[label=\alph*.]
                  
                  \item \texttt{elements} から
                  \texttt{GUIElement.Type == Screen} の\texttt{GUIElement}をすべて抽出する。

                  \item 抽出した\texttt{GUIElement}を、
                  各要素が保持する \texttt{Y} 座標の昇順(Y座標の値が小さい順)でソートする。

                  \item 整列後の順に、
                  各\texttt{GUIElement}の \texttt{GUIElement.Name} を取り出し、
                  画面一覧を表す配列 \texttt{screenList} を生成する。

                  \item Markdown文字列の1行目から、
                  画面一覧見出し「\texttt{\# 画面一覧}」の有無の判定を行う。

                  \item \texttt{screenList} が空でない場合、
                  3.i.d.の見出しの有無に応じて以下の処理を行う。
                  \begin{itemize}
                        \item 画面一覧見出しが存在する場合：
                        
                        既存の画面一覧フィールドを、
                        \texttt{screenList} に基づく箇条書き「- \textless \texttt{GUIElement.\allowbreak Name} \textgreater」へ置換する。
                        
                        \item 画面一覧見出しが存在しない場合：
                        
                        画面要素の生成および置換は行わない。
                  \end{itemize}

                  \item \texttt{screenList} が空の場合は、
                  画面一覧フィールドの生成および置換は行わない。
            \end{enumerate}

            \item タイムアウト要素の生成
            \begin{enumerate}[label=\alph*.]
                  \item \texttt{elements} から
                  \texttt{GUIElement.Type == Timeout}の\texttt{GUIElement}を抽出する。

                  \item 抽出結果が存在する場合は、\texttt{lines}配列の
                  2行目を「 - \texttt{<GUIElement.Name>でタイムアウト}」に置換する。

                  \item 抽出結果が存在しない場合は、
                  \texttt{lines}配列の2行目を空文字列にする。
            \end{enumerate}

            \item\texttt{lines} 内から、ボタン一覧見出し \texttt{"\#\#\# 有効ボタン一覧"} の行位置を完全一致で探索し、行番号を\texttt{buttonIdx} として保持する。また、イベント一覧見出し \texttt{"\#\#\# イベント一覧"} の行位置を完全一致で探索し、行番号を\texttt{eventIdx} として保持する。
            
            \item ボタン要素の生成
            \begin{enumerate}[label=\alph*.] 
                  \item ボタン一覧の並び順を表す配列として、
                        \texttt{buttonList} を生成する。
                        \texttt{buttonList} は、以下の処理で生成する。
                        \begin{enumerate}[label=\Roman*.]
                              \item \texttt{elements}から \texttt{GUIElement.Type \allowbreak == \allowbreak Button} の\texttt{GUIElement}をすべて抽出する。
                              \item 抽出した\texttt{GUIElement}を、\texttt{GUIElement}が保持する\texttt{Y} 座標の昇順(Y座標の値が小さい順)でソートする。
                              \item 各\texttt{GUIElement}の \texttt{GUIElement.Name} を3.iv.IIで整列した順に取り出し、\texttt{buttonList}に格納する。
                        \end{enumerate}
                  \item \texttt{buttonList} が空でない場合、
                        \texttt{buttonIdx} の有無に応じて以下の処理を行い、
                        Markdown文字列のボタン一覧フィールドを更新する。
                        ただし、\texttt{buttonList} が空の場合は、空見出し生成を避けるため、
                        以下の処理は行わない。
                        \begin{itemize}
                              \item \texttt{buttonIdx} が存在する場合：
                              
                                    \texttt{lines}の既存のボタン一覧フィールドを
                                    \texttt{buttonList} に基づく箇条書き「- \textless \texttt{GUIElement.Name} \textgreater」に置換する。
                              \item \texttt{buttonIdx} が存在しない場合：
                                    
                              \texttt{buttonList}に基づき新規にボタン一覧セクションを生成する。ボタン一覧セクションを生成する位置は、
                                    \texttt{eventIdx} の有無に応じて、以下のように決定する。
                                    \begin{itemize}
                                          \item \texttt{eventIdx} が存在する場合:
                                          
                                          イベント一覧見出しの直前へ挿入
                                          \item \texttt{eventIdx} が存在しない場合:
                                          
                                          \texttt{lines}末尾へ追加
                                    \end{itemize}
                        \end{itemize}
            \end{enumerate}

            \item イベント要素の生成
            \begin{enumerate}[label=\alph*.]

                  \item\texttt{elements} から、
                  \texttt{GUIElement.Type == Event} かつ
                  \texttt{GUIElement.Name} が空でない\texttt{GUIElement}を抽出し、
                  イベント要素リスト \texttt{eventList} として
                  一時的に保持する。

                  \item \texttt{elements} から、
                  \texttt{GUIElement.Type == Button} または
                  \texttt{GUIElement.Type == Timeout}
                  の\texttt{GUIElement}を抽出し、
                  それらをCTM上の配置順序を表す
                  \texttt{Y} 座標の昇順で整列する。
                  整列後の要素列を、
                  関連元要素リスト \texttt{sourceList} として保持し、
                  イベント一覧の出力順序として用いる。

                  \item \texttt{sourceList} の各要素について、
                  \texttt{eventList} を参照し、
                  イベント要素を特定する。
                  対応付け結果は、
                  連想配列である対応表 \texttt{linkTable} に格納する。
                  \texttt{linkTable} は関連元要素（ボタン要素またはタイムアウト要素）をキーとして、
                  対応するイベント要素を値とする配列である。
                  ボタン要素およびタイムアウト要素とイベント要素の対応付けを、以下に示す。
                  \begin{itemize}
                        \item イベント要素が \texttt{Target} を保持している場合:
                        
                        当該 \texttt{Target} と一致する
                        \texttt{Target} を持つボタン要素またはタイムアウト要素を
                        イベント要素と対応付ける。
                        
                        \item イベント要素が \texttt{Target} を保持せず、
                        かつ分岐イベント要素(\texttt{IsBranch == true})である場合:
                        
                        イベント要素の \texttt{Name} と
                        ボタン要素の \texttt{Target} が一致するものを
                        対応付ける。
                  \end{itemize}

                  \item  3.v.c  
                  で生成した対応表 \texttt{linkTable} を参照し、
                  関連元要素の整列順に従ってイベント一覧フィールドを生成する。
                  具体的には、
                  各ボタン要素またはタイムアウト要素に対応付けた
                  イベント要素について、
                  以下の規則に基づき Markdown 仕様のイベント記述を生成する。生成したイベント記述を1つのイベント記述ブロックとして、イベント記述ブロックの順序を表す配列
                  \texttt{blocksOrder}に格納する。

                  \begin{itemize}
                        \item ボタン要素に対応するイベント要素の場合:
                        
                        イベント要素の \texttt{Name} 、および、ボタン要素の \texttt{Name} を用いて
                        「\texttt{- <ボタン要素の\texttt{Name}>押下 \allowbreak → \allowbreak <イベント要素の\texttt{Name}>}」
                        の形式で 1 行のイベント記述を生成する。
                        
                        \item タイムアウト要素に対応するイベント要素の場合:
                        
                        「\texttt{- タイムアウト → <イベント要素の\texttt{Name}>}」
                        の形式でイベント記述を生成する。

                        \item 分岐イベント要素の場合:
                        
                        先頭行として
                        「\texttt{- <ボタン要素の\texttt{Name}>押下 \allowbreak → \allowbreak}」
                        を生成し、
                        続く各行として、
                        各分岐条件、および、分岐先イベントを
                        「\texttt{  - <イベント要素の\texttt{Branches.Condition}> \allowbreak → \allowbreak <イベント要素の\texttt{Branches.Target}>}」
                        の形式でネストされた箇条書きとして生成する。
                  \end{itemize}

                  \item イベント一覧フィールドの置換  
                  \begin{itemize}
                        \item \texttt{eventIdx} が存在する場合:
                        
                        既存のイベント一覧フィールドを、
                        生成した\texttt{blocksOrder}に逐次置換する。
                        \item \texttt{eventIdx} が存在しない場合:
                        
                        生成した\texttt{blocksOrder}を
                        \texttt{lines}の末尾に追加する。
                  \end{itemize}

            \end{enumerate}
      \end{enumerate}
      
      \item linesを正規化する。
      \texttt{lines}の正規化に関する処理を、以下に示す。
      \begin{enumerate}[label=\roman*.]
            \item \texttt{lines} を先頭から順に走査し、各行が空行 (空文字列、または空白文字のみからなる行)
                  であるかを判定する。
            \item 直前の行も空行である場合、該当行は連続空行とみなし、該当行のみを排除する。
            \item \texttt{lines} の先頭が空行である場合、見出し行や本文の直前に不要な空行が存在する状態となるため、先頭の空行を除去する。
            \item \texttt{lines} の末尾が空行である場合、文書末尾に不要な空行が存在する状態となるため、末尾の空行を除去する。
      \end{enumerate}
      \item 正規化後の \texttt{lines}を出力する。
\end{enumerate}


