\chapter{拡張した2VSGの実装}\label{cha:Implementation}

本章では、拡張部分の実装について説明する。
今回拡張で追加した部分も既存の\tool 同様にMVVMアーキテクチャ（\ref{sec:MVVM}節を参照）を採用している。拡張部分のシステム構成を、図\ref{fig:system-architecture}に示す。
拡張後の\tool は、以下の6つの主要な処理部で構成する。
\begin{itemize}
  \item プロジェクト管理部
  \item 解析部
  \item GUI要素生成部
  \item 変換部
  \item 描画部
  \item ユーザ操作監視部
\end{itemize}

MVVM に基づき、各処理部は責務を明確にし、連携して動作する。
View 層は、GUI の表示およびユーザ入力の受付を担い、画面上の図を描画部により可視化する。
ViewModel 層は、View 層と Model 層間のデータバインディングを担当し、
ユーザ入力を、それぞれの操作についてユーザ操作監視部で判断し、
Model 層の各処理部へ処理を指示する。
Model 層は、プロジェクト管理部、解析部、GUI要素生成部、変換部から構成し、
仕様データの永続化、解析、GUI要素データの生成、およびマークダウン形式からVDM++形式への変換を担う。
この構成により、Model 層は View 層を直接参照せず、
ViewModel 層を介して状態のみを受け渡す。
本ツールでは、CTM（\ref{sec:CTM}節を参照）上に表示する表示する各CTM要素が保持するデータGUIElement（\ref{sec:ParsingComponent}節を参照）の中で座標データ、および、ノードサイズデータを保持するGUIElementをGUI要素と呼ぶ。

以降、各処理部の実装について、それぞれ説明する。

\begin{figure}[tp]
  \centering
  \includegraphics[width=0.8\linewidth]{./images/system-architecture.png}
  \caption{拡張した\tool のシステム構成図}
  \label{fig:system-architecture}
\end{figure}


\section{プロジェクト管理部}\label{sec:ProjectManagementComponent}

プロジェクト管理部は、ユーザが操作するプロジェクト（フォルダ配下のMarkdownファイル）の状態を管理し、
解析部（\ref{sec:ParsingComponent}節を参照）、および、変換部（\ref{sec:ConversionComponent}節を参照）へ渡す入力データ（Markdown文字列）、
およびGUI要素生成部（\ref{sec:GUIElementGenerationComponent}節を参照）へ渡すGUI要素の配置情報（JSONファイル）を準備するとともに、
編集結果をファイルへ出力する処理部である。
本処理部でのファイルシステム入出力には 、.NET 標準ライブラリの System.IO （\ref{sec:NET_MAUI}節を参照）を用いる。
本処理部の入力は、ユーザ操作監視部（\ref{sec:UserOperationMonitoring}節を参照）によるユーザ操作イベント、および、プロジェクトフォルダでる。出力は、解析部、および、変換部へ渡すMarkdown文字列および変換済みVDM++文字列である。

本処理部は、以下の4つの主要な処理から構成する。
\begin{itemize}
  \item フォルダ選択処理
  \item フォルダおよびファイル探索処理
  \item ファイル読込処理
  \item ファイル更新処理
\end{itemize}

以降、各処理について説明する。

\subsection{フォルダ選択処理}\label{sec:PM_SelectFolder}
フォルダ選択処理は、ユーザが編集対象のプロジェクトフォルダを選択した際、
選択したプロジェクトフォルダの探索、および、読込の基準パスを確定する処理である。
本処理ではFolderPicker（\ref{sec:CommunityToolkit.Maui}節を参照） を用い、
取得したフォルダパスを \verb|SelectedFolderPath| に保持した上でフォルダおよびファイル探索処理（\ref{sec:PM_FolderFileSearch}節を参照）を呼び出す。
プロジェクト管理部はユーザがフォルダ選択操作を行った際にユーザ操作監視部（\ref{sec:UserOperationMonitoring}節を参照）が通知する要求に応じて本処理を実行する。

本処理の流れを、以下に示す。
\begin{enumerate}
  \item ユーザ操作監視部からのフォルダ選択要求を受け取る。
  \item 選択フォルダのパスを \verb|SelectedFolderPath| として保持する。
  \item フォルダおよびファイル探索処理を呼び出し、フォルダのツリー表示用データ構造であるFolderItems クラス（\ref{sec:PM_FolderFileSearch}節を参照）を構築する。
  \item フォルダ内にファイル、および、フォルダが存在しない場合、現在選択しているフォルダを編集中のアイテムとして対応付ける。
\end{enumerate}

\subsection{フォルダおよびファイル探索処理}\label{sec:PM_FolderFileSearch}
フォルダおよびファイル探索処理、ツリー表示用の内部データである\verb|ObservableCollection<FolderItem> FolderItems|を構築しする処理である。
本処理は、フォルダ選択処理（\ref{sec:PM_SelectFolder}節を参照）から\verb|SelectedFolderPath|を入力として受け取る。そして、
\verb|SelectedFolderPath| 配下のフォルダ、および、ファイル群を走査し、Markdownファイルおよびフォルダ構造を取得しする。
その後、取得した情報を基に、ツリー表示用の内部データである\verb|ObservableCollection<FolderItem> FolderItems|を構築し、出力する。
本処理では、JSONファイル、および、VDM++ファイルは探索対象外とし、Markdownファイル（拡張子 .md）、および、フォルダのみを対象として\verb|FolderItems|に格納する 。

本処理の流れを、以下に示す。

\begin{enumerate}
\item \verb|SelectedFolderPath| が示すフォルダをルートフォルダとして、
ルートフォルダ配下のフォルダおよびファイルを再帰的に走査する。
走査時には、Markdown ファイル（拡張子 .md）と
それ以外のファイルを区別し、
フォルダと Markdown ファイルのみを抽出する。

\item 取得したフォルダ情報およびファイル情報を、
階層構造を保持可能な内部データ構造として整理する。
ここでは、各フォルダおよびファイルを
FolderItems クラスとして表現し、
以下の属性を保持する。

\begin{itemize}
\item Name：ファイルまたはフォルダの名称
\item FullPath：ファイルまたはフォルダの絶対パス
\item Level：ルートフォルダからの階層レベル
\item IsExpanded：ツリー表示において展開状態かどうか
\item IsVisible：ツリー表示において現在可視状態かどうか
\item Children：子フォルダおよびファイルの要素リスト
\end{itemize}

このデータ構造により、
フォルダの展開、および、折り畳み操作に応じて、
子要素の表示状態を動的に制御できる。

\item 構築した FolderItemsクラス の階層構造を保持し、
ユーザ操作監視部からの展開、および、選択操作に即時反映できる状態にする。
\end{enumerate}

\subsection{ファイル読込処理}
ファイル読込処理は、
ユーザがツリー上で選択したMarkdownファイルを対象として、
その内容を読み込み、
解析部（\ref{sec:ParsingComponent}節を参照）および変換部（\ref{sec:ConversionComponent}節を参照）
に必要なMarkdown文字列を初期化する処理である。
本処理では、
.NET 標準ライブラリの System.IO.File クラス（\ref{sec:NET_MAUI}節を参照）を用いて
ファイル内容を文字列として読み込む。
本処理では、入力として選択したMarkdownファイルパス\verb|SelectedFilePath|を受け取り、\verb|SelectedFilePath|のMarkdownファイル内容を文字列として出力する。

本処理の流れを、以下に示す。

\begin{enumerate}
\item ユーザがツリー上のMarkdownファイルを選択すると、
ユーザ操作監視部から\verb|SelectedFilePath|とファイル読み込み要求を取得し、
ファイル内容をstring型のMarkdown文字列として読み込む。

\item 読み込んだMarkdown文字列を内部データとして保持する。
以降の処理、および、処理部では、Markdownファイルを直接解析、および、編集せず、
内部データとして保持したMarkdown文字列を解析、および、編集する。

\item 対象Markdownファイルと同名の
JSONファイル（拡張子 .positions.json）が存在するかを確認する。
同名のJSONファイルが存在する場合には、
GUI要素の座標情報を読み込み、
GUI要素生成処理（\ref{sec:GUIElementGenerationComponent}節を参照）において配置情報を復元できるようにする。
\end{enumerate}

\subsection{ファイル更新処理}\label{sec:FileUpdateProcess}
ファイル更新処理は、VDM\texttt{++}仕様生成機能（\ref{sec:VDM++-generation-function}節を参照）の結果をプロジェクトファイルへ反映し、
Markdown仕様、VDM++仕様、およびGUI要素の配置情報を
一貫した状態で保存する処理である。

本処理は、ユーザ操作監視部（\ref{sec:UserOperationMonitoring}節）からの
ファイル更新要求、またはノード移動操作確定をトリガーとして実行する。

本処理は、現在のGUI要素リスト（\ref{sec:GUIElementGenerationComponent}節を参照）、
選択中のファイルパス\verb|SelectedFilePath|を入力として受け取り、更新後のMarkdownファイル、VDM++ファイル、JSONファイルを保存する。

本処理の流れを、以下に示す。
\begin{enumerate}
      \item ユーザ操作監視部により
      ファイル更新要求、または、ノードの移動操作確定通知を受け取る。

      \item 現在のGUI要素リストに基づいて
      変換部のGUI操作からMarkdown仕様への変換処理（\ref{sec:GUItoMarkdownConversionProcess}節を参照）に変更を加える前のMarkdown文字列を渡し、変更を加えたMarkdown文字列を取得する。

      \item Markdown仕様およびVDM++仕様の更新を行う。
        \begin{enumerate}[label=\roman*.]
          \item 生成したMarkdown文字列を、
                選択中ファイルパスに対応するMarkdownファイル（.md）へ書き出し、保存する。
          \item 保存したMarkdown文字列を変換部のMarkdown仕様からVDM++仕様への変換処理（\ref{sec:ConversionComponent}節を参照）へ渡し、
                VDM++文字列を生成する。
          \item 生成したVDM++文字列を、
                選択中Markdownファイルと同名のVDM++ファイル（.vdmpp）へ書き出し、保存する。
                ファイルが存在しない場合には、新規作成する。
      \end{enumerate}
      \item JSONファイルのGUI要素配置情報を更新する
      \begin{enumerate}[label=\roman*.]
        \item 受け取った現在のGUI要素リストより、ノードの座標情報を取得する
        
        \item 取得した座標情報をもとに、
              要素名、X座標、Y座標の組として整理し、
              JSON形式のデータ構造を生成する。

        \item 生成したJSONデータを、
              選択中Markdownファイルと同名の
              .positions.json ファイルへ書き出し、保存する。
              ファイルが存在しない場合には、新規作成する。
      \end{enumerate}
\end{enumerate}
JSONファイルの出力例を、コード\ref{lst:JSON_example}に示す。このJSONファイルには、GUI要素の名称と座標情報を含み、Markdown仕様記述ルール（\ref{sec:Specrule}節を参照）に含ない位置情報のみを保持する。

この処理により、
GUI表示、Markdown仕様、VDM++仕様、および配置情報が
常に同一の仕様内容を表す状態を維持する。

\begin{figure}[tp]
\begin{lstlisting}[caption={JSONファイル出力例}, label={lst:JSON_example}, language={}]
[
  {
    "Name": "1",
    "X": 20,
    "Y": 111
  },
  {
    "Name": "2",
    "X": 20,
    "Y": 211
  },
  {
    "Name": "3",
    "X": 20,
    "Y": 311
  }
]
\end{lstlisting}
\end{figure}

\section{解析部}\label{sec:ParsingComponent}

解析部は、記述ルールに従ったMarkdown仕様記述（コード\ref{lst:markdown_example}を参照）の文字列を解析し、CTM（\ref{sec:CTM}節を参照）表示および操作の基礎となる構造データを生成する処理部である。
本処理部では、表\ref{tab:ctm_elements}に示したCTM要素を抽出することを目的とする。

本処理部では、.NET 標準ライブラリの System.Text.RegularExpressions（\ref{sec:System.Text.RegularExpressions}節を参照）を用いて Markdown文字列の各行を解析する。

本処理部の入力はMarkdown文字列であり、出力はGUIElementのリストである。
ここで、GUIElement は、各CTM 要素を構成する構造データである。
各要素の種別、名称、遷移先、条件分岐情報、および
CTM上での配置位置を保持する。

以降、処理について説明する。
具体例に用いるMarkdown仕様記述を、コード\ref{lst:markdown_example}に示す。
具体例に対する処理後のGUIElement一覧を表\ref{tab:gui_element_example}に、Branchesを表\ref{tab:event_branch_example}に示す。

\subsection{解析処理}\label{sec:ParsingProcess}

本処理は、Markdown仕様から、画面、タイムアウト、ボタン、イベント、および条件分岐を抽出し、
これらを表\ref{tb:GUIElement}、\ref{tb:EventBranch}に示すGUIElementとして構造化し、GUIElementのリストである\verb|elements|を出力する処理である。

本処理は、ユーザがプロジェクト内のMarkdown仕様ファイルを選択または更新した際に、
プロジェクト管理部が呼び出す。
本処理はファイル単位で実行し、
各ファイルの内容に基づいて \verb|elements| を生成する。

本処理では、独自の正規表現パターンを用いてMarkdown文字列の各行を解析し、各CTM要素を抽出する。
各CTM要素の抽出に使用する独自の正規表現パターンを、表\ref{tab:parsing_rules}に示す。

本処理の流れを、図\ref{fig:parsing-flow}と以下に示す。
以下では具体例を用いて説明する。

\begin{table}[tp]
\centering
\caption{GUIElementデータ構造}
\label{tb:GUIElement}
\begin{tabular}{|l|l|p{7cm}|}
\hline
\textbf{属性名} & \textbf{型} & \textbf{説明}\\ 

\hline
Type & GuiElementType & CTM要素の種類（Screen, Button, Event, Timeout） \\

\hline
Name & string & CTM要素の名称 \\

\hline
Target & string & 遷移先となるCTM要素名 \\

\hline
X & float & CTM上での X 座標 \\

\hline
Y & float & CTM上での Y 座標 \\

\hline
Width & float & CTM要素の横幅 \\
  
\hline
Height & float & CTM要素の高さ \\

\hline
IsSelected & bool & CTM要素がユーザにより選択されているかどうか \\
\hline
IsFixed & bool & ドラッグによる移動が不可能かどうか \\

\hline
Branches & List\textless EventBranch \textgreater & 条件分岐を表す分岐リスト \\


\hline
IsBranch & bool & Branchesを保持しているかどうか \\

\hline
\end{tabular}
\end{table}

\begin{table}[tp]
\centering
\caption{EventBranchデータ構造}
\label{tb:EventBranch}
\begin{tabular}{|l|l|p{10cm}|}
\hline
\textbf{属性名} & \textbf{型} & \textbf{説明}\\ 
\hline
EventBranch.Condition & string & 分岐条件 \\

\hline
EventBranch.Target & string & 分岐条件成立時のイベント \\
\hline
\end{tabular}
\end{table}

\begin{table}[tp]
\centering
\caption{解析部で用いる正規表現パターン}
\label{tab:parsing_rules}
\begin{tabular}{|l|p{6cm}|p{6cm}|}
\hline
\textbf{規則名} & \textbf{定義（概要）} & \textbf{用途} \\
\hline
BulletPattern
& 箇条書き行を定義する正規表現
（箇条書き記号と本文Textを抽出）
& ボタン名、画面名、イベント行、タイムアウト行の
箇条書き本文の抽出判定 \\
\hline
EventPattern
& 「Name（タイムアウト時間、分岐条件） → Target（イベント）」形式を分解する正規表現
& タイムアウト行および条件分岐行の
「→」を基準とした左右要素分解 \\
\hline
OperationPattern
& 「Operation(押下) → Target（イベント）」形式を分解する正規表現
& イベント一覧における
トリガ―、イベントの抽出 \\
\hline
\end{tabular}
\end{table}

\begin{figure}[tp]
  \centering
  \includegraphics[width=0.7\linewidth]{./images/kaiseki_flow.png}
  \caption{解析処理フロー}
  \label{fig:parsing-flow}

\end{figure}

\begin{enumerate}
    \item 各行の分割。 

    プロジェクト管理部から入力として受け取ったMarkdown文字列を改行で分割し、
    各行を1つの要素とした配列を生成する。
    実装では、改行で分割した各行から \verb|\r| を除去し、
    \verb|List<string> lines| として保持する。
    以降の処理は、この \verb|lines| を走査対象として用いる。


    \item 先頭行判定。
    
    先頭行（\verb|lines[0]|）を判定材料として、
    Markdown仕様記述ルール（\ref{sec:Specrule}節を参照）に則り、「画面一覧クラス」か「画面クラス」かを決定する。
    具体的には
    \verb|lines[0] == "# 画面一覧"| を満たす場合、
    画面一覧クラスとして扱い3.の画面抽出へ進む。
    一方で、 \verb|lines[0]| が（\verb|"## "|） で始まる場合、
    画面クラスとして扱い、
    タイムアウト4.、ボタン5.、イベント6.の抽出へ進む。
    
    具体例では、先頭行 \verb|lines[0]| が
    \verb|## 画面1| であるため、例で示すMarkdown仕様は画面クラスとして扱う。

    \item 画面抽出。
    
    画面一覧クラスを解析する場合、
    2行目（\verb|lines[1]|）以降を走査し、箇条書き本文を画面名として抽出する。
    ここでは、抽出した画面をそれぞれ \verb|GUIElement.Type| に \verb|Screen|、
    \verb|GUIElement.Name| に画面名を設定したGUIElementを生成し、\verb|elements| に追加する。

    \item タイムアウト抽出。

    画面クラスを解析する場合、
    Markdown仕様記述ルール（\ref{sec:Specrule}節を参照）に基づき、タイムアウト時間は2行目に記述するため、
    2行目（\verb|lines[1]|）をタイムアウト定義行として扱い、
    箇条書き本文からタイムアウト情報を抽出する。
    ここでは、箇条書き本文中の 「\verb|で|」 を探索し、
    「\verb|で|」の前の部分をタイムアウト名として抽出する。
      抽出したタイムアウト名をもとに、
    \verb|GUIElement.Type|に \verb|Timeout|、\verb|GUIElement.Name|にタイムアウト名を設定したGUIElementを生成し、\verb|elements| に追加する。
    
    具体例では、2行目の「\verb|- 80 秒でタイムアウト|」をタイムアウト定義行として解析する。
    箇条書き本文から「\verb|で|」より前の文字列を抽出し、
    CTM要素の種類として\verb|GUIElement.Type = Timeout|、タイムアウト名として\verb|GUIElement.Name = 80 秒|を設定したGUIElementを生成し、 \verb|elements| に追加する。

    \item ボタン抽出。

    ボタン一覧セクションを抽出する。
    \begin{enumerate}[label=\roman*.]
      \item 見出し行を探索する。

      4.の次行以降を走査し、行頭が（\verb|#|）から始まるかどうかを確認する。
      （\verb|#|）を見つけた場合、該当行の（\verb|#|）を取り除いた文字列を見出し名として抽出する。
      抽出した見出し名が「有効ボタン一覧」と一致した場合、該当行をボタン一覧セクションの開始行として扱う。
      
      具体例では、タイムアウトの次行である3行目\verb|lines[2]|から走査を開始し、4行目\verb|lines[3]|の見出し行\verb|### 有効ボタン一覧|を発見する。

      \item ボタン一覧セクションの範囲を決定する。

      見出し行の次行以降を走査し、ボタン一覧セクションの終了行を探索する。
      終了行の判定は、以下のいずれかを満たす行に到達した場合とする。
      \begin{itemize}
        \item 見出し行（\verb|###| または \verb|##| で始まる行）に到達する。
        \item ファイル末尾に到達する。
      \end{itemize}

      具体例では、ボタン一覧セクションの終了行は13行目\verb|lines[12]|の見出し行\verb|### イベント一覧|であるため、12行目\verb|lines[11]|までを対象とする。

      \item ボタン要素を抽出する。

      ボタン一覧セクション内の各行について、\verb|BulletPattern| により箇条書きかどうかを判定し、
      箇条書き本文をボタン名として抽出する。
      箇条書きでない行は有効ボタン定義として扱わず、スキップする。
      
      具体例では、5行目\verb|lines[4]|から12行目\verb|lines[11]|までの各行を走査し、
      箇条書き本文をそれぞれボタン名として抽出する。5行目の「\verb|ボタン1|」から、
      11行目の「\verb|確定|」までをそれぞれ抽出し、12行目は空行であるためスキップする。

      \item ボタン要素をGUIElementとして生成する。

      抽出したボタン名について、\verb|HashSet<string>|（\ref{sec:NET}節を参照）を用いて重複判定を行う。
      重複していない場合、\verb|GUIElement.Type|に \verb|Button|、
      \verb|GUIElement.Name|にボタン名を設定したGUIElementを生成し、\verb|elements| に追加する。
      重複していた場合、該当行のボタン要素の生成をスキップする。
      
      具体例では、抽出した各ボタン名について重複判定を行い、
      全て重複していないため、各ボタン名をもとに
      \verb|GUIElement.Type = Button|、\verb|GUIElement.Name = ボタン1 ～ 確定|を設定したGUIElementを生成し、\verb|elements| に追加する
      \end{enumerate}

    \item イベント一覧セクションを抽出する。
      \begin{enumerate}[label=\roman*.]
      \item 見出し行を探索する。

      5.同様に見出し行を探索し、
      抽出した見出し名が「イベント一覧」と一致した場合、
      当該行をイベント一覧セクションの開始行として扱う。

      具体例では、ボタンセクションの次行である13行目\verb|lines[12]|から走査を開始し、
      13行目\verb|lines[12]|の見出し行\verb|### イベント一覧|を発見する。

      \item イベント一覧セクションの範囲を決定する。

      見出し行の次行以降を走査し、
      イベント一覧セクションの終了行を探索する。
      終了行の判定は、以下のいずれかを満たす行に到達した場合とする。

      \begin{itemize}
      \item 見出し行（\verb|###| または \verb|##| で始まる行）に到達する。
      \item ファイル末尾に到達する。
      \end{itemize}

      具体例では、イベント一覧セクションの終了行はファイル末尾であるため、最後の行である23行目\verb|lines[22]|までを対象とする。

      \item イベント候補行を抽出する。

      イベント一覧セクション内の各行について、
      \verb|BulletPattern| により箇条書き行かどうかを判定する。
      箇条書き本文をイベント候補文字列として抽出する。
      箇条書きでない行はイベント定義ではないためスキップする。

      具体例では、14行目\verb|lines[13]|から24行目\verb|lines[23]|までの各行を走査し、
      箇条書き本文をそれぞれイベント候補文字列として抽出する。
      14行目の「\verb|タイムアウト → 画面A へ|」から、
      23行目の「\verb|  - 表示部に1 が入力されていない → 画面F へ|」までをそれぞれ抽出する。


      \item イベント行の書式を判定する。

      抽出したイベント候補文字列に対し、
      まず、\verb|OperationPattern| を適用し、
      「\verb|Operation（押下）→ Target（イベント）|」形式に該当するかを判定する。
      該当する場合は、
      （\verb|押下 →|）の直前までの文字列を対象ボタン名\verb|buttonkey|、
      （\verb|→|）以降の文字列をイベント内容\verb|eventContent|としてそれぞれ抽出する。
      上記形式に該当しない場合は、￥verb|EventPattern| を適用し、
      「左辺 \verb|→| 右辺」の形式として扱い、
      （\verb|→|）を境に左側文字列\verb|leftText|と右側文字列\verb|rightText|を抽出する。

      具体例では、14行目の「\verb|タイムアウト → 画面A へ|」が
      「\verb|EventPattern|」に該当するため、
      左側文字列\verb|leftText|を「\verb|タイムアウト|」、
      右側文字列\verb|rightText|を「\verb|画面A へ|」として扱う。
      15行目の「\verb|ボタン1 押下 → 表示部に1 を追加|」が
      「\verb|Operation（押下）→ Target（イベント）|」形式に該当するため、
      抽出した対象ボタン名\verb|buttonkey|を「\verb|ボタン1|」、
      イベント内容\verb|eventContent|を「\verb|表示部に1 を追加|」として扱う。

      \item イベント行とボタン要素の対応付けを行う。

      「\verb|押下 →|」形式のイベントについて、
      抽出した対象ボタン名\verb|buttonkey|をキーとして、
      \verb|elements|から既に生成済みのボタン要素を探索する。
      探索時には、
      前後空白の除去、
      大文字小文字を無視した比較を行い、
      対応するボタン要素を特定する。
      対応するボタン要素が存在する場合、
      当該イベントをそのボタンに対応するイベントとして扱う。
      
      具体例では、15行目の「\verb|ボタン1 押下 → 表示部に1 を追加|」に対し、
      抽出した対象ボタン名\verb|buttonkey|である「\verb|ボタン1|」をキーとして
      \verb|elements|から対応するボタン要素を探索し、特定する。
      対応するボタン要素\verb|ボタン1|はelementsに存在しするため、
      対応するボタン要素のTarget属性\verb|GUIElement.Target|にイベント内容\verb|eventContent|である\verb|表示部に1 を追加|を設定する。
      21行目の「\verb|確定 押下 → |」に対しては、
      抽出した対象ボタン名\verb|buttonkey|である「\verb|確定|」をキーとして
      \verb|elements|から対応するボタン要素を探索し、特定する。
      対応するボタン要素\verb|確定|はelementsに存在するが、
      イベント内容\verb|eventContent|が空であるため、
      当該イベントは条件分岐イベントとして扱い、スキップする。


      \item 条件分岐イベントを抽出する。\\
      iv.で抽出した\verb|OperationPattern|に該当するイベントのうち、\verb|eventContent|が空であるものを条件分岐イベントとして扱う。
      抽出した条件分岐イベントについては、\verb|OperationPattern|に該当した行を条件分岐イベントの親イベント行として扱い、
      \verb|GUIElement.Type = Event|、\verb|GUIElement.Name = buttonkey|、
      \verb|GUIElement.IsBranch = true|を設定する。
      その後、親イベント行の直後の行から順に走査し、条件分岐行を収取し、\verb|elements|へ条件分岐イベントとして追加する。
      収集した条件分岐行に対する詳細な処理規則および生成するデータ構造については、
      \ref{sec:ParsingBranch}節で詳しく説明する。

      \item 単一イベント要素を生成する。\\
      条件分岐イベントに該当しない場合、
      解析部は単一イベントとして要素生成を行う。
      「\verb|押下 →|」形式のイベントでは、
      \verb|GuiElementType.Event| のイベント要素を生成する。
      このとき、
      表示および識別に用いるため、
      \verb|eventContent|を \verb|GUIElement.Name| および
      \verb|GUIElement.Target| に設定し、
      \verb|elements| に追加する。
      一方で、
      「左辺 \verb|→| 右辺」形式のイベントでは、
      左辺\verb|leftText|をイベント種別名、
      右辺\verb|rightText|を遷移先識別子として扱い、
      同様にイベント要素を生成する。
      また、左辺文字列（\verb|leftText|）が「\verb|leftText == タイムアウト|」である場合、
      解析部は、既に生成済みのタイムアウト要素（\verb|GUIElement.Type == Timeout|）を
      \verb|elements| から探索する。
      該当するタイムアウト要素が存在する場合、
      \verb|GUIElement.Type|に \verb|Event| 、\verb|GUIElement.Name|に\verb|rightText|、
      \verb|GUIElement.Target| に該当するタイムアウト要素の\verb|GUIElement.Name|を設定する。

      具体例では、14行目の「\verb|タイムアウト → 画面A へ|」に対し、
      抽出した左辺文字列\verb|leftText|が「\verb|タイムアウト|」であるため、
      既に生成済みのタイムアウト要素\verb|80 秒|を
      \verb|elements| から探索し、特定する。
      該当するタイムアウト要素\verb|80 秒|はelementsに存在するため、
      \verb|GUIElement.Type = Event|、\verb|GUIElement.Name = 画面A へ|、
      \verb|GUIElement.Target = 80 秒|を設定したGUIElementを生成し、 \verb|elements| に追加する。
      15行目の「\verb|ボタン1 押下 → 表示部に1 を追加|」に対し、
      \verb|GUIElement.Type = Event|、\verb|GUIElement.Name = 表示部に1 を追加|、
      \verb|GUIElement.Target = 表示部に1 を追加|を設定したGUIElementを生成し、 \verb|elements| に追加する。


      \end{enumerate}

    \item 全要素の抽出完了後、
    解析部は\verb|elements|を出力する。
    GUI要素生成部は、この出力を入力として
    GUI上の操作可能要素を構築する。
\end{enumerate}

\subsection{条件分岐の解析処理}\label{sec:ParsingBranch}

本処理では、イベント一覧セクション内に記述する条件分岐イベントを対象として、
分岐条件と分岐先をどのように抽出し、
GUIElementのBranchesへ格納するかを説明する。
条件分岐イベントは、単一のイベントに対して複数のイベントを定義する記述であり、
通常の単一イベントとは異なる解析規則を適用する必要があるため、
独立した処理として扱う。

本処理では、条件分岐イベントを以下の形式で判定する。

\begin{itemize}
  \item 親イベント行：\verb|- {ボタン名}押下 →|
  \item 分岐行：\verb|  - {条件} → {遷移先}|
\end{itemize}

解析部は、親イベント行を \verb|OperationPattern|
（\verb|Operation（押下） → Target（イベント）|）で判定し、
条件分岐行を \verb|EventPattern|（\verb|Name → Target|）で判定する。

\subsubsection{親イベント行の判定と抽出}

本処理は、 既に生成済みの対応するボタン要素を特定し、
親イベント要素を生成するための基準情報として保持する。
このとき、本処理はボタン名の表記ゆれに対応するため、
抽出したボタン名に対して前後空白の除去を行い、
大文字小文字を無視した一致判定を行う。

\subsubsection{終了条件}

本処理は、親イベント行を検出した後、
親イベント行の直後の行から順に走査し、
分岐行を収集する。
ただし、無関係な行を誤って分岐として取り込まないために、
分岐行の収集範囲に終了条件を設ける。

本処理は、以下の条件のいずれかを満たす行に到達した時点で、
分岐行の収集を終了する。

\begin{itemize}
  \item 空行に到達する。
  \item 見出し行（\verb|###| または \verb|##| で始まる行）に到達する。
  \item 箇条書きとして解釈できない行に到達する。
  \item \verb|OperationPattern|またはタイムアウト行として解釈できる行に到達する。
\end{itemize}

この終了条件により、
ユーザが外部エディタでインデントを崩した場合や、
イベント一覧の記述形式が部分的に乱れた場合でも対応できる範囲が広がる。

\subsubsection{分岐行の解析とBranchesへの格納}

本処理は、収集対象となる分岐行について、
箇条書き本文を抽出した後、
\verb|EventPattern| を用いて \verb|Name| と \verb|Target| を分解する。
本処理は、ここで抽出した \verb|Name| を分岐条件（Condition）、
\verb|Target| を分岐先（Target）として扱う。

本処理は、（Condition, Target）の組を
\verb|EventBranch| として生成し、
親イベント要素の \verb|Branches| に追加する。
本処理は、複数の分岐行を収集した場合でも、
行の出現順を保持したまま \verb|Branches| に追加し，
GUI上の分岐表示と仕様記述の順序を一致させる。

解析部は、条件分岐を含むイベントについて、
親イベント要素に \verb|Branches| を設定した状態で
\verb|elements|へ追加する。
GUI要素生成部は、この \verb|Branches| を参照し、
CTM上の条件ノードおよび分岐先ノードを生成するための入力として利用する。


\begin{table}[tp]
\centering
\caption{コード3.1のMarkdown仕様記述例から生成するGUIElement一覧}
\label{tab:gui_element_example}
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Type} & \textbf{Name} & \textbf{Target} & \textbf{備考} \\
\hline
Screen & 画面1 & -- & 画面クラス \\ 
\hline
Timeout & 80 秒 & -- & タイムアウト定義 \\ 
\hline
Button & ボタン1 & 表示部に1 を追加 & 有効ボタン \\ 
\hline
Button & ボタン2 & 表示部に2 を追加 & 有効ボタン \\ 
\hline
Button & ボタン3 & 表示部に3 を追加 & 有効ボタン  \\ 
\hline
Button & ボタン4 & 表示部に4 を追加 & 有効ボタン \\ 
\hline
Button & ボタン5 & 表示部に5 を追加 & 有効ボタン \\ 
\hline
Button & ボタン6 & 表示部に6 を追加 & 有効ボタン \\ 
\hline
Button & 確定 & -- & 有効ボタン \\ 
\hline
Event & 画面A & 80 秒 & タイムアウトイベント \\ 
\hline
Event & 表示部に1 を追加 & 表示部に1 を追加 & 単一イベント \\ 
\hline
Event & 表示部に2 を追加 & 表示部に2 を追加 & 単一イベント \\ 
\hline
Event & 表示部に3 を追加 & 表示部に3 を追加 & 単一イベント \\ 
\hline
Event & 表示部に4 を追加 & 表示部に4 を追加 & 単一イベント \\ 
\hline
Event & 表示部に5 を追加 & 表示部に5 を追加 & 単一イベント \\ 
\hline
Event & 表示部に6 を追加 & 表示部に6 を追加 & 単一イベント \\ 
\hline
Event & 確定押下 & -- & 条件分岐を含むイベント \\ 
\hline
\end{tabular}
\end{table}

\begin{table}[tp]
\centering
\caption{確定押下イベントにおける条件分岐の内容}
\label{tab:event_branch_example}
\begin{tabular}{|l|l|}
\hline
\textbf{Condition} & \textbf{Target} \\ 
\hline
表示部に1 が入力されている & 画面K \\ 
\hline
表示部に1 が入力されていない & 画面F \\ 
\hline
\end{tabular}
\end{table}




\section{GUI要素生成部}\label{sec:GUIElementGenerationComponent}
解析部（\ref{sec:ParsingComponent}節を参照）で抽出した\verb|elements|を基に、
画面上で操作可能なCTM要素のデータリストを生成する処理である。
本処理部の目的は、
Markdown仕様の論理構造を、
ユーザが直感的に把握、および操作できる視覚的表現へと変換することである。

なお、本論文では解析部およびGUI要素生成部の双方において
同一のGUIElementクラスを用いているが、
解析部で扱うelementsは、その各GUIElementの意味的データ（Type、Name、Target、Branches）のみを保持した状態であり、
本論文では、このGUIElementに表示および操作に関する属性（座標、サイズ、操作可否）を付与したものをGUI要素とする。また、GUI要素のリストを
GUI要素リストとする。

本処理部では、GUI要素リストを生成し、
以降の描画部（\ref{sec:DrawingComponent}節を参照）、および、ユーザ操作監視部（\ref{sec:UserOperationMonitoring}節を参照）に渡す。
GUI要素生成部は、
単なる要素の対応付けを行うのではなく、
配置、サイズ、操作可否といった
GUIとしての振る舞いを規則に基づいて決定する。

通常ノードの描画仕様を表\ref{tab:gui_node_spec}に、
条件分岐イベントにおける可視ノードの描画仕様を表\ref{tab:gui_node_branch}に、それぞれ示す。
GUI要素の座標は、プロジェクト管理部でMarkdown仕様が入力された際に同名のJSONファイルが存在する場合、\verb|elements|
内の\verb|GUIElement.Name|をキーとして
JSONファイルの（コード\ref{lst:JSON_example}を参照）を走査し、該当要素の座標情報を読み込む。
JSONファイルが存在しない場合、
もしくは、JSONファイル内に該当要素の座標情報が存在しない場合は、
以下に示す初期配置規則に基づき決定する。
GUI要素の初期配置は、
\verb|elements|内の GUIElement のノードの種類に基づいて決定する。
画面要素（Screen）は一定間隔で縦方向に配置し、
複数画面が存在する場合でも
重なりが生じないようオフセットを付与する。
要素のサイズについても、
ノードの種類ごとに既定値を設定している。
初期配置座標は、
インデックス $i$ に基づきで式\ref{eq:initial_position_x}、\ref{eq:initial_position}で決定する。
ここでインデックス $i$ は、
同一種別の GUIElementに対して、
解析順に付与される 0 始まりの連番を表す。
ここで、
$d$ は要素間の縦方向間隔を表す定数である。
$X_0$、$Y_0$ は初期配置の基準座標を表す定数であり、
CTM（\ref{sec:CTM}節を参照）描画領域の左上を原点とする座標系において、
画面端との余白を確保するために
定数としてあらかじめ定義する値である。
\begin{equation} \label{eq:initial_position_x}
X_i = X_0\quad
\end{equation}
\begin{equation}\label{eq:initial_position}
Y_i = Y_0 + i \cdot d
\end{equation}

生成するGUI要素には、
ユーザ操作に関する属性も付与する。
例えば、タイムアウト（Timeout）要素は1画面につき単一のものとして扱うため移動不可とし、
ボタンやイベント要素はドラッグ操作による移動を可能とする。
この操作可否の区別により、
ユーザが誤って画面構造全体を崩すことを防止している。

また、イベント（Event）を表すGUI要素については、
対象ボタンおよびイベントの関連付けを行い、
描画部において矢印として表現できるよう、
接続情報を内部に保持する。

本処理の流れを以下に示す。
\begin{enumerate}
  \item 解析部の出力である
        GUIElement のリスト \verb|elements| を入力として受け取る。

  \item \verb|elements| を先頭から順に走査し、
        \verb|GUIElement|について \verb|GUIElement.Type| を参照し、
        ノードの種別を判定する。

  \item \verb|GUIElement.Type|が\verb|Screen|だった場合、
        以下の手順で画面要素を生成する。
        \begin{enumerate}[label=\roman*.]
          \item 画面要素のインデックス $i$ を取得する。
          \item 表\ref{tab:gui_node_spec} に示す仕様に基づき、
                画面要素のGUI要素を生成する。
          \item 初期配置座標を式\ref{eq:initial_position_x}、式\ref{eq:initial_position}に基づいて算出し、
                生成したGUI要素の\verb|X| および \verb|Y| に設定する。
          \item 生成したGUI要素のサイズ情報（Width, Height）を
                画面要素用の既定値に設定する。
          \item ユーザ操作による移動を許可するため、
                生成したGUI要素の\verb|IsFixed |を\verb|false| に設定する。
          \item 生成したGUI要素をGUI要素リストへ追加する。
        \end{enumerate}

  \item \verb|GUIElement.Type|が\verb|Button|だった場合、
        以下の手順でボタン要素を生成する。
        \begin{enumerate}[label=\roman*.]
            \item ボタン要素の初期配置座標を算出する。
            \item 表\ref{tab:gui_node_spec} に基づき、
                ボタン要素のGUI要素を生成する。
            \item 生成したGUI要素のサイズ情報をボタン要素用の既定値に設定する。
            \item ユーザ操作による移動を許可するため、
                生成したGUI要素の\verb|IsFixed |を\verb|false| に設定する。
            \item 生成したGUI要素をGUI要素リストへ追加する。
        \end{enumerate}

  \item \verb|GUIElement.Type|が\verb|Timeout|だった場合、
        以下の手順でタイムアウト要素を生成する。
        \begin{enumerate}[label=\roman*.]
            \item 固定配置用のオフセットを適用し、初期座標を算出する。
            \item 表\ref{tab:gui_node_spec} に基づき、
                タイムアウト要素のGUI要素を生成する。
            \item 生成したGUI要素のサイズ情報をタイムアウト要素用の既定値に設定する。
            \item タイムアウト要素は1画面につき1つのみとするため、
                生成したGUI要素の\verb|IsFixed |を\verb|true| に設定し、
                ドラッグ操作による移動を禁止する。
            \item 生成したGUI要素をGUI要素リストへ追加する。
        \end{enumerate}

  \item \verb|GUIElement.Type|が\verb|Event|だった場合、
        以下の手順でイベント要素を生成する。
        \begin{enumerate}[label=\roman*.]
          \item イベント要素に対応するボタン要素またはタイムアウト要素を
                それぞれの\verb|Target| 情報に基づいて特定する。
          \item 表\ref{tab:gui_node_spec} に基づき、
                矩形形状のGUI要素を生成する。
          \item 初期配置座標を、
                対応するボタンおよびタイムアウトの右側に配置されるよう算出する。
          \item 生成したGUI要素のサイズ情報を Event 用の既定値に設定する。
          \item ユーザ操作による移動を許可するため、
                生成したGUI要素の\verb|IsFixed |を\verb|false| に設定する。
          \item 遷移関係を表すため、
                接続元および接続先の関連情報を内部に保持する。
        \end{enumerate}

  \item イベント要素が条件分岐情報
        （\verb|Branches|）を保持している場合、
        以下の処理を行う。
        \begin{enumerate}[label=\roman*.]
          \item 当該イベント要素を
                条件分岐イベントとして判定する。
          \item イベント親行ノードを非表示対象として設定する。
          \item 各\verb|EventBranch| に対応する
                条件ノードおよび分岐先ノード生成用の情報を保持する。
        \end{enumerate}

  \item 全要素の走査が完了した後、
        生成したGUI要素リストを
        描画部へ出力する。
\end{enumerate}

\begin{table}[tp]
\centering
\caption{通常ノードの描画仕様}
\label{tab:gui_node_spec}
\begin{tabular}{|l|l|c|c|p{4.5cm}|}
\hline
\textbf{要素} & \textbf{形状} & \textbf{幅(px)} & \textbf{高(px)} & \textbf{配置・備考} \\
 \hline
Screen
& 角丸矩形
& 160 & 45
& CTM描画領域の左列に縦配置（間隔80Px）、移動可 \\
 \hline

Button
& 楕円
& 80 & 45
& CTM描画領域の左列に縦配置（間隔80Px）、移動可 \\
 \hline

Event
& 矩形
& 160 & 45
& CTM描画領域の右列に縦配置（間隔80Px）、条件分岐時は本体非表示、移動可 \\
 \hline

Timeout
& 楕円
& 112 & 45
& 左上固定配置，移動不可 \\
 \hline
\end{tabular}
\end{table}



\begin{table}[tp]
\centering
\caption{条件分岐イベントにおける可視ノードの描画仕様}
\label{tab:gui_node_branch}
\begin{tabular}{|l|l|c|c|p{4cm}|}
\hline
\textbf{要素} & \textbf{形状} & \textbf{幅(px)} & \textbf{高(px)} & \textbf{備考} \\
 \hline
Condition
& ダイヤモンド
& 176 & 50
& 分岐条件を表す可視ノード \\
 \hline

Target
& 矩形
& 152 & 36
& 分岐先を示す中間ノード \\
 \hline
\end{tabular}
\end{table}


\section{変換部}\label{sec:ConversionComponent}
変換部は、Markdown仕様およびVDM++仕様の記述形式を相互に変換する処理部である。
本処理部では、Markdown仕様とVDM++仕様の変換に加え、ユーザによるGUI操作結果をMarkdown仕様へ反映する処理を担う。
Markdown仕様からVDM++仕様への変換処理については、既存の\tool のMarkdown変換部（\ref{sec:Structure}節を参照）を利用する。

GUI操作からMarkdown仕様への変換処理は、GUI操作による編集結果を差分として反映するのではなく、
GUI要素リストの現在状態からMarkdown仕様を全体を再生成する方式を採用している。
この設計により、
編集履歴や操作順序に依存しない一貫した仕様を生成できる。

\subsection{GUI操作からMarkdown仕様への変換処理}\label{sec:GUItoMarkdownConversionProcess}
本処理は、GUI要素生成部（\ref{sec:GUIElementGenerationComponent}節を参照）で生成したGUI要素リスト、および編集前のMarkdown仕様文字列を入力として、
編集後Markdown仕様文字列を生成する処理である。
まず、GUI要素リストのGUI要素を、種類および関連関係に基づいて分類する。
次に、各GUI要素を
Markdown仕様記述として出力する順序を決定する。

出力規則は\tool のMarkdown仕様記述ルール（\ref{sec:Specrule}節を参照）に準拠しており、
画面定義、タイムアウト定義、ボタン一覧、イベント一覧、条件分岐の順にMarkdown仕様の要素を出力する。
変換処理の結果として生成したMarkdown仕様は、
プロジェクト管理部に引き渡し、
ファイル更新処理（\ref{sec:FileUpdateProcess}節を参照）により保存する。
これにより、
CTM上の編集操作と仕様記述との間に
常に一貫した対応関係が保たれる。

本処理の流れを、以下に示す。
\begin{enumerate}
  \item GUI要素生成部
        （\ref{sec:GUIElementGenerationComponent}節）で生成した。
        GUI要素リストを取得する。
  \item 取得したGUI要素リスト、プロジェクト管理部で取得したMarkdown仕様文字列を
        出力順序決定のために出力順序整理処理に入力する（\ref{sec:ConversionOrderProcess}節を参照）。
        
  \item 出力順序整理処理が出力したMarkdown文字列各行を1つの要素とした配列である
  \verb|lines| に格納したMarkdown仕様記述各行を連結し、
        最終的なMarkdown仕様文字列
        \verb|markdown| を生成する。
  \item 生成した \verb|markdown| を
        プロジェクト管理部にわたし、ファイル更新処理により保存する。

\end{enumerate}


\subsection{出力順序整理処理}\label{sec:ConversionOrderProcess}
本処理では、GUI要素リスト \verb|elements| 、およびMarkdown文字列を入力として、
Markdown文字列のうち「有効ボタン一覧」および「イベント一覧」の並び順を
GUI上の配置順序に一致するよう再構成する。
本処理は、Markdown仕様の内容を変更することなく、
GUI上の配置順序とMarkdown上の記述順序を一致させることのみを目的とする。


なお、本処理では、
GUI 要素リストに存在しないイベント記述であっても、
Markdown 仕様中に記述が存在する場合は、
仕様欠落を防ぐ目的から自動的に削除しない設計としている。

本処理の流れを、以下に示す。
\begin{enumerate}
  \item 入力として、Markdown文字列と
        GUI要素リストを受け取る。
  \item Markdown文字列を読み込み、Markdown文字列各行を1つの要素とした配列（\verb|lines|）として保持する。
  \item 行配列 \verb|lines| 内から、
        ボタン一覧見出し \verb|"### 有効ボタン一覧"| の行位置を \verb|buttonIdx| として探索し、
        イベント一覧見出し \verb|"### イベント一覧"| の行位置を \verb|eventIdx| として探索する。
  \item ボタン一覧の並び順を表す配列として、
        \verb|buttonList| を生成する。
        \verb|buttonList| は、以下の処理で生成する。
        \begin{enumerate}[label=\roman*.]
          \item GUI要素リストから \verb|GUIElement.Type==Button| のGUI要素を抽出する。
          \item 抽出したGUI要素を、GUI要素が保持する\verb|Y| 座標の昇順（Y座標の値が小さい順）で整列する。
          \item 各GUI要素の \verb|GUIElement.Name| をⅱ.で整列した順に取り出し、\verb|buttonList|に格納する。
        \end{enumerate}
  \item \verb|buttonList| が空でない場合、
        \verb|buttonIdx| の有無に応じて以下の処理を行い、
        Markdown文字列のボタン一覧セクション（見出しおよび箇条書き）を更新する。
        \begin{itemize}
          \item \verb|buttonIdx| が存在する場合：
                既存のボタン一覧セクションを
                \verb|buttonList| に基づく箇条書きへ置換する。
          \item \verb|buttonIdx| が存在しない場合：
                新規にボタン一覧セクションを生成する。ボタン一覧セクションを生成する位置は、
                \verb|eventIdx| の有無に応じて以下のように決定する。
                \begin{itemize}
                  \item \verb|eventIdx| が存在する場合:イベント一覧見出しの直前へ挿入
                  \item \verb|eventIdx| が存在しない場合:行配列末尾へ追加
                  \end{itemize}
        \end{itemize}
        ただし、\verb|buttonList| が空の場合は、空見出し生成を避けるため、
        ボタン一覧セクションの置換、および、新規作成を行わない。
  \item イベント一覧の並び順を表す配列として、
        \verb|blocksOrder| を生成する。
        \verb|blocksOrder| は、以下の処理で生成する。
        \begin{enumerate}[label=\roman*.]
          \item GUI要素リストから \verb|GUIElement.Type==Event| かつ \verb|GUIElement.Name| が空でないGUI要素を抽出する。
          \item 抽出したGUI要素を、GUI要素が保持する\verb|Y| 座標の昇順で整列する。
          \item 各GUI要素の \verb|GUIElement.Name| をⅱ.で整列した順に取り出し、\verb|blocksOrder| に格納する。
        \end{enumerate}
  \item Markdown文字列上のイベント一覧セクションを「ブロック単位」で再構成する。
        本処理では、イベント一覧セクション内の記述を、以下の処理でブロック化する。
        \begin{enumerate}[label=\roman*.]
          \item \verb|"- "| で始まる行をブロック先頭とする。
          \item 直後に続く行のうち、
                先頭が2スペース以上（\verb|"  "|）またはタブ（\verb|"\t"|）で始まる行を同一ブロックに含める。
        \end{enumerate}
        これにより、条件分岐を含むイベント（ネストされた箇条書き）も
        1つのブロックとして保持され、並べ替え時に分割されない。
  \item ブロックの並べ替えは、\verb|blocksOrder| の順序に従って行う。
        編集前のMarkdown文字列を走査し、\verb|blocksOrder| と部分一致しなかったブロックは、
        仕様欠落を防ぐため元の順序を保ったまま末尾へ追加する。
  \item 整理後の \verb|lines| に対し、空行を正規化する処理を適用し、
        連続空行や不要な空行を除去する。
  \item 正規化後の \verb|lines|を出力する。
\end{enumerate}


\section{描画部}\label{sec:DrawingComponent}
描画部は、GUI要素生成部（\ref{sec:GUIElementGenerationComponent}節を参照）
から受け取ったGUI要素リストをもとに、ツール上部に設置するボタンとCTM描画領域を描画および再描画する処理部である。
本処理部の目的は、ユーザが仕様の構造を直感的に把握できる視覚的表現を提供することである。
本描画部は、Microsoft.Maui.Graphics（\ref{sec:Microsoft.Maui.Graphics}節を参照）を用いて実装している。

描画部は、
各GUI要素を外接矩形として扱い、
要素種別に応じた形状、寸法、および描画スタイルを適用する。
これらの寸法および形状は、
GUI要素生成部で定義した規則に基づいて決定しており、
通常ノード、および、条件分岐ノードについては、
それぞれ表\ref{tab:gui_node_spec}、
表\ref{tab:gui_node_branch}に示す描画仕様を用いる。

\subsection{初期描画処理}
初期描画処理は、GUI要素生成部から受け取ったGUI要素リストをもとに、
初期状態のGUI表示を生成する処理である。

本処理の流れを、以下に示す。
\begin{enumerate}
    \item CTM描画領域を初期化し、背景を消去する。
    \item GUI要素リストを走査し、各GUI要素の種別を判定する。
    \item 要素種別に応じて、矩形、楕円、菱形などの描画形状および描画スタイルを決定する。
    \item 各GUI要素が保持する座標情報をもとに、CTM描画領域上へノード本体およびラベル文字列を描画する。
    \item 遷移関係を表す要素については、GUI要素生成部で設定した接続情報を参照し、
    接続元および接続先ノードの外接矩形から矢印の開始点および終了点を算出した上で、
    遷移を示す矢印を描画する。
    \item 条件分岐を持つ要素\verb|GUIElement.IsBranch == true|については、通常のイベントノード本体を描画せず、条件分岐構造を展開して描画する。具体的には、以下の手順で描画を行う。
    \begin{enumerate}[label=\roman*.]
      \item 条件表示領域を「条件文を表示する矩形」として描画し、
      その右側に分岐点を示す菱形を描画する。

      \item \verb|Branches|の要素数 $n$ を取得し、縦方向に $n$ 個並べて配置する。
      このとき、\verb|Branches|は同一幅、同一高さの外接矩形として扱い、
      条件表示領域のY座標を基準とし、一定の垂直間隔でオフセットを加えることで配置する。
      具体的には、基準Y座標を $Y_{\mathrm{base}}$、
      \verb|Branches|の垂直間隔を $\Delta Y$（分岐先領域の高さを含む定数）とすると、
      $i$ 番目の\verb|Branches|のY座標 $Y_i$ は式\ref{eq:branch_y}により算出する。

      \begin{equation}\label{eq:branch_y}
            Y_i = Y_{\mathrm{base}} + i \cdot \Delta Y
      \end{equation}

      \item 分岐条件から分岐先へは，
      外接矩形に基づき矢印の開始点および終了点を算出して接続線を描画する。
      開始点は分岐点（菱形）の右端中央、終了点は分岐先領域の左端中央とし、
      矢印を付与して分岐方向を示す。
      分岐先が画面遷移を表す場合は、分岐先名称が画面要素として解釈できるかを判定し、
      解決できない場合は矢印の描画スタイルを変更して参照不整合を視覚的に示す。

      \item 条件分岐は編集対象の単位となるため、
      描画と同時にヒットテスト用の領域情報を生成して保持する。
      保持する情報は、条件表示領域の外接矩形、分岐点（菱形）の外接矩形、
      および各分岐先領域の外接矩形であり、
      これらを親要素および分岐番号 $i$ に対応付けて記録する。
\end{enumerate}


    \item 描画したすべてのノードおよび分岐要素について、
    外接矩形情報を記録し、ヒットテスト処理
    （\ref{sec:HitTestProcess}節）で利用可能な状態として保持する。
\end{enumerate}

\subsubsection{矢印の開始点および終了点の算出}
矢印の開始点および終了点は、接続元および接続先ノードの外接矩形情報をもとに算出する。
具体的には、接続元ノードの右端中央を開始点とし、接続先ノードの左端中央を終了点とする。
ここで、接続元ノードの左上座標を$(X_s, Y_s)$、幅を$W_s$、高さを$H_s$、
接続先ノードの左上座標を$(X_t, Y_t)$、幅を$W_t$、高さを$H_t$とすると、
開始点$(x_s, y_s)$および終了点$(x_t, y_t)$は、式\ref{eq:arrow_points_start}、\ref{eq:arrow_points_end}により算出する。

\begin{equation}\label{eq:arrow_points_start}
      (x_s, y_s) = (X_s + W_s, Y_s + \frac{H_s}{2})
\end{equation}


\begin{equation}\label{eq:arrow_points_end}
      (x_t, y_t) = (X_t, Y_t + \frac{H_t}{2})
\end{equation}
\subsection{再描画処理}
再描画処理は、ユーザ操作や仕様変更に伴い、GUI表示を更新する処理である。
ユーザ操作監視部からの再描画要求を受け取り、再描画したツール上部のボタン、およびCTM描画領域を更新する。
この処理により、仕様の変更が即座に視覚的に反映され、ユーザが最新の状態を把握できるようにする。

本処理の流れを、以下に示す。

\begin{enumerate}
    \item ユーザ操作監視部からの再描画要求を受信する。
    \item 更新対象となるGUI要素について、座標情報および選択状態などの内部状態を反映する。
    \item 描画領域を初期化し、既存の描画内容を消去する。
    \item 初期描画処理と同一の手順により、全GUI要素および遷移関係を再描画する。
    \item ユーザ操作監視部により選択中と判定された要素については、枠線の色および太さを変更し、視覚的に選択状態であることを強調表示する。
\end{enumerate}

\section{ユーザ操作監視部}\label{sec:UserOperationMonitoring}

ユーザ操作監視部は、GUI上で発生するユーザ入力を監視し、
操作対象のGUI要素を特定した上で、必要な処理部へ処理要求を発行する統括処理部である。
本処理部は、 MVVM における View 層と ViewModel 層間の橋渡しとして振る舞い、
描画部（\ref{sec:DrawingComponent}節）と連携してヒットテストを行い、
プロジェクト管理部（\ref{sec:ProjectManagementComponent}節）へ更新要求をする。

本処理部の入力は、 クリック座標およびドラッグ移動量のポインタイベント、
描画部が保持するGUI要素外接矩形情報、
GUI要素リストである。
出力は、選択状態の更新要求、ノード座標更新要求、編集コマンド（追加、削除、編集）の要求、
再描画要求、および必要に応じたファイル更新要求である。

本処理部で用いるポインタ座標は、.NET MAUI （\ref{sec:NET_MAUI}）の座標系に基づいており、
CTM描画領域の左上を原点とする座標系である

以降、各ユーザ操作に対する処理を説明する。

\subsection{ヒットテスト処理}\label{sec:UOM_HitTest}
ヒットテスト処理は、ユーザの操作座標がどのGUI要素に該当するかを判定し、
操作対象GUI要素を確定する処理である。

本処理は、描画部が保持する外接矩形情報を用いて、
操作座標が外接矩形内に含まれるかを判定する。
ユーザの操作座標 $(x, y)$ が矩形内に存在するかどうかは、
式\ref{eq:hit}により判定する。

\begin{equation}\label{eq:hit}
X \leq x \leq X + W \;\land\; Y \leq y \leq Y + H
\end{equation}

本処理の流れを、以下に示す。
\begin{enumerate}
  \item 操作座標 $(x, y)$ を受け取る。
  \item 描画部から外接矩形リスト \verb|hitRects| を取得する。外接矩形リスト\verb|hitRects|は、
        表\ref{tab:hit_test_rect}に示す属性を持つ。   
  \item \verb|hitRects| を先頭から走査し、式\ref{eq:hit}により包含判定を行う。
  \item 複数のCTM要素がヒットする場合は、描画順序（前面優先）に基づき最前面CTM要素を採用する。
  \item 採用したCTM要素を \verb|SelectedElement| として確定する。
\end{enumerate}

\begin{table}[tp]
\centering
\caption{ヒットテスト用外接矩形情報}
\label{tab:hit_test_rect}
\begin{tabular}{|c|c|p{8cm}|}
\hline
\textbf{属性} & \textbf{型} & \textbf{説明} \\
\hline
Element & GuiElement &
当該外接矩形に対応する GUI 要素。
ヒット判定が成立した場合、選択するGUI要素。 \\
\hline
X & float &
外接矩形の左上 X 座標。 \\
\hline
Y & float &
外接矩形の左上 Y 座標。\\
\hline
W & float &
外接矩形の幅。\\
\hline
H & float &
外接矩形の高さ。\\
\hline
ZIndex & int &
描画順序を表す値。
複数の外接矩形がヒットした場合に、前面要素を判定するために用いる。 \\
\hline
\end{tabular}
\end{table}

\subsection{左クリック操作監視処理}\label{sec:UOM_Click}
左クリック操作監視処理は、左クリックによる選択操作を検出し、
対象GUI要素の選択状態（\verb|IsSelected|）を更新する処理である。

入力は左クリック座標、出力は選択状態更新および再描画要求である。

本処理の流れを、以下に示す。
\begin{enumerate}
  \item 左クリック座標 $(x, y)$ を受け取る。座標と同時に
        左ボタンによるクリックイベントの通知を受け取る。
  \item ヒットテスト処理（\ref{sec:UOM_HitTest}節）を呼び出し、\verb|SelectedElement| を確定する。
  \item 既存の選択GUI要素が存在する場合、当該GUI要素の \verb|IsSelected| を \verb|false| に更新する。
  \item \verb|SelectedElement| の \verb|IsSelected| を \verb|true| に更新する。
  \item 描画部へ再描画要求を発行し、強調表示状態を更新する。
\end{enumerate}

\subsection{右クリック操作監視処理}\label{sec:UOM_Context}
右クリック操作監視処理は、右クリックによる編集要求を検出し、
対象GUI要素の種類（Screen、Button、Event、Timeout）および条件分岐に基づき、
表示する操作候補（コンテキストメニュー）を決定し、コンテキストメニュー内コマンドの選択結果を編集コマンドとして発行する処理である。

本処理の入力は、右クリック座標と現在の GUI要素リスト、出力は編集コマンド（追加、削除、編集）である。
本処理の流れを以下に示す。
\begin{enumerate}
  \item 右クリック座標 $(x, y)$ を受け取る。座標と同時に
        右ボタンによるクリックイベントの通知を受け取る。
  \item ヒットテスト処理（\ref{sec:UOM_HitTest}節）により\verb|SelectedElement|を確定する。
  \item 対象GUI要素の \verb|Type| に応じて候補操作集合を決定する。
        例えば Button 要素には「イベント追加」を含め、Screen 要素には「画面編集」「タイムアウト編集」を含める。
  \item 条件分岐イベントの場合は、分岐領域（branch）に対する右クリックを区別し、
        \verb|branchIndex|（分岐番号）を編集要求に含める。
        これにより「分岐の追加、分岐の編集、分岐の削除」を対象分岐に紐付けて実行できる。
  \item ユーザが選択した候補操作を編集コマンドとして編集コマンド実行処理（\ref{sec:UOM_EditCommand}節）へ通知する。
\end{enumerate}

\subsection{ダブルクリック操作監視処理}\label{sec:UOM_DoubleClick}
ダブルクリック操作監視処理は、画面（Screen）ノードに対するダブルクリックを検出し、
対象画面クラスへ画面遷移を行う処理である。

本処理は、直前クリック時刻と今回クリック時刻の差分が閾値以内であるかによりダブルクリックを判定し、
対象要素が Screen である場合のみ操作を成立させる。
成立時は当該 Screen を対象に画面遷移を行う。

\subsection{ドラッグ操作監視処理}\label{sec:UOM_Drag}
ドラッグ操作監視処理は、GUI要素の配置変更操作を検出し、
対象GUI要素の座標 \verb|X, Y| を更新する処理である。
入力は押下開始座標、ポインタ移動量、解放座標であり、出力は更新後座標および（必要に応じた）ファイル更新要求である。

本処理の流れを、以下に示す。
\begin{enumerate}
  \item 左クリック開始時にヒットテストを行い、ドラッグ対象 \verb|DraggingElement| を確定し、押下開始座標を取得する。
  \item 対象GUI要素の \verb|IsFixed| を参照し、移動不可である場合はドラッグを開始しない。
  \item ドラッグ開始時点のGUI要素座標と、押下開始座標との差分を \verb|offsetX, offsetY| として保持する。
  \item ポインタ移動イベントごとに、現在座標から \verb|offset| を差し引き、
        新しいGUI要素座標 $(X', Y')$ を算出して \verb|DraggingElement.X, DraggingElement.Y| を更新する。
  \item 座標更新ごとに描画部へ再描画要求を行い、移動結果を即時反映する。
  \item 解放時に開放座標を確定し、CTM要素の配置を変更した状態でスナップが入り、配置情報の保存が必要な場合は
        プロジェクト管理部のファイル更新処理（\ref{sec:FileUpdateProcess}節）を要求する。
\end{enumerate}

\subsection{編集コマンド実行処理}\label{sec:UOM_EditCommand}

本処理は、右クリックメニューや画面上の操作ボタン（追加、編集、削除、保存等）により確定した編集コマンドを実行し、
必要な入力値（名称、遷移先、条件文など）をポップアップで取得した上で、
GUI要素リストを更新する処理である。

本処理は、編集コマンド種別、選択中要素 \verb|SelectedElement|、GUI要素リストを入力として受け取り、
要素の追加、更新、削除を行った上で、更新後のGUI要素リスト、描画部への再描画要求、
プロジェクト管理部へのファイル更新要求、UI上の表示ボタン切替状態を出力する。

本処理の流れを以下に示す。

\begin{enumerate}
  \item 編集コマンド種別と、操作対象\verb|SelectedElement|を受け取る。

  \item コマンド種別に応じて、必要な入力項目を決定する。
  例えば、ボタン追加ではボタン名、イベント追加では「対象ボタン」「イベント内容の選択」「イベント」を要求する。
  条件分岐追加では「条件文」と「イベント」を要求する。

  \item 入力が必要な場合、ポップアップ（入力ダイアログ）を表示し、ユーザから文字列を取得する。
  \begin{itemize}
    \item キャンセルした場合は、処理を中断し、GUI要素リストを変更しない。
    \item 入力値が空、または重複する場合は、エラー表示（警告）を行い、再入力または中断とする。
  \end{itemize}

  \item コマンド種別に応じてGUI要素リストを更新する。
  更新規則を、以下に示す。
  \begin{enumerate}[label=\roman*.]
    \item \textbf{画面追加}：
          新しい画面要素（\verb|Type=Screen, Name=画面名|）をGUI要素リストに追加する。
          プロジェクト管理部へ更新要求を通知する（\ref{sec:FileUpdateProcess}節を参照）。

    \item \textbf{ボタン追加}：
             新しいボタン要素（\verb|Type=Button, Name=ボタン名|）をGUI要素リストに追加する。
          既存ボタン名と重複する場合は追加しない。
          プロジェクト管理部へ更新要求を通知する（\ref{sec:FileUpdateProcess}節を参照）。

    \item \textbf{イベント追加（単一イベント）}：
          対象ボタン（Button）を特定し、イベント要素（\verb|Type=Event|）を生成して追加する。
          このとき、イベント内容を \verb|Name| と \verb|Target| に保持し、
          描画部が矢印接続を構成できるようにする。
              プロジェクト管理部へ更新要求を通知する（\ref{sec:FileUpdateProcess}節を参照）。

    \item \textbf{タイムアウト追加}：
          対象画面に対するTimeout要素（\verb|Type=Timeout|）を追加または更新する。
          1画面につき1つとする規則により、既存Timeoutが存在する場合は更新（上書き）する。
              プロジェクト管理部へ更新要求を通知する（\ref{sec:FileUpdateProcess}節を参照）。

    \item \textbf{条件分岐の追加}：
          条件分岐を伴う親イベント要素（\verb|Type=Event, Branches=null|）を特定し、
          取得した（Condition, Target）を \verb|EventBranch| として \verb|Branches| に追加または更新する。
          プロジェクト管理部へ更新要求を通知する（\ref{sec:FileUpdateProcess}節を参照）。

    \item \textbf{削除}：
          対象GUI要素をGUI要素リストから除去する。
          併せて、参照関係（イベントが参照するボタン、タイムアウト、分岐参照）を探索し、
          存在しないボタンにつながるイベントが発生する不整合を避けるため関連要素も必要に応じて更新する。
              プロジェクト管理部へ更新要求を通知する（\ref{sec:FileUpdateProcess}節を参照）。
  \end{enumerate}

  \item GUI要素リスト更新後、GUI上の表示ボタン群（外観切替）を更新する。
        例えば、画面一覧編集モードでは「画面追加、削除」ボタンのみを表示し、
        個別画面編集モードでは「ボタン追加、イベント追加、タイムアウト追加」を表示する。

  \item 描画部へ再描画要求を要求し、要素追加、削除、分岐表示を即時反映する。

  \item プロジェクト管理部のファイル更新処理（\ref{sec:FileUpdateProcess}節）を要求する。
\end{enumerate}
